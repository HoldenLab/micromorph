{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"micromorph","text":"<p> <code>micromorph</code> is a python package designed to perform morphological measurements of bacterial microscopy images acquired using either phase contrast, or fluorescence microscopy. </p> <p><code>micromorph</code> can be used as a package, or through the napari plugin <code>napari-micromorph</code>. We recommend starting with the napari plugin to get a sense of what value can be calculated and what parameters are optimal for boundary and midline detection for a specific sample.</p> <p>You can read about the package and what it can do in our pre-print.</p> <p>Warning</p> <p>The documentation is still in development, so some parts may be incomplete or missing. We are  working on it!</p>"},{"location":"#installation","title":"Installation","text":"<p>You can install the package by running:</p> <p><code>pip install micromorph</code></p> <p>If you also want to install the components necessary to run the batch processing GUI, you can run:</p> <p><code>pip install micromorph[gui]</code></p> <p>If you want to use the napari plugin, you will need to run:</p> <p><code>pip install napari-micromorph</code></p> <p>You will need to have set up a python environment and installed napari before you can make use of most of the package functionality. See this guide if you are unsure how to do that.</p> <p>You can also download the plugin through the napari-hub directly inside your napari install.</p>"},{"location":"#examples","title":"Examples","text":"<p>Read the pages in the Usage section, or check out the scripts and notebooks available in the GitHub repository.</p>"},{"location":"#contributing","title":"Contributing","text":"<p>Feel free to open issues or pull requests if you spot any bugs to our software or would like to suggest improvements!</p> <p>You can install an editable version of the package by cloning this GitHub repository and installing the local version of the package on your environment by running <code>pip install -e .</code> after navigating to the folder in your terminal.</p> <p>Packages required to build the documentation are available if you install the software with <code>pip install micromorph[docs]</code>. You can then build the documentation by running the command <code>mkdocs serve</code>, which will make the documentation available locally (typically at <code>http://127.0.0.1:8000/</code>). You can add the flag <code>--livereload</code> to ensure the documentation is automatically rebuilt upon editing. </p>"},{"location":"API/bacteria/","title":"Bacteria Class","text":"<p>options:   docstring_style: numpy   docstring_section_style: table   show_docstring_attributes: true</p>"},{"location":"API/bacteria/#micromorph.bacteria.Bacteria.Bacteria","title":"<code>Bacteria</code>","text":"<p>A class to store all the properties of a single bacterium.</p> <p>Parameters:</p> Name Type Description Default <code>img</code> required <code>mask</code> required <code>options</code> <code>dict()</code> <p>Attributes:</p> Name Type Description <code>centroid</code> <code>the centroid of the bacterium</code> <code>xc</code> <code>the x-coordinate of the centroid</code> <code>yc</code> <code>the y-coordinate of the centroid</code> <code>xc_nm</code> <code>the x-coordinate of the centroid in nm</code> <code>yc_nm</code> <code>the y-coordinate of the centroid in nm</code> <code>bbox</code> <code>the bounding box of the bacterium</code> <code>axis_major_length</code> <code>the major axis length of the bacterium</code> <code>axis_minor_length</code> <code>the minor axis length of the bacterium</code> <code>orientation</code> <code>the orientation of the bacterium</code> <code>area</code> <code>the area of the bacterium</code> <code>boundary</code> <code>the boundary of the bacterium</code> <code>medial_axis</code> <code>the medial axis of the bacterium</code> <code>medial_axis_extended</code> <code>the medial axis of the bacterium extended to the boundary</code> <code>slice</code> <code>the slice of the stack where the bacterium is located (default is zero)</code> <code>all_widths</code> <code>the widths of the bacterium at different points along the medial axis</code> Source code in <code>src\\micromorph\\bacteria\\Bacteria.py</code> <pre><code>class Bacteria:\n    \"\"\"\n    A class to store all the properties of a single bacterium.\n\n    Parameters\n    ----------\n    img: the image containg the bacterium\n    mask: the mask of the bacterium\n    options: a dictionary with options to be passed to the functions used to calculate the morphological properties of the bacterium\n\n    Attributes\n    ----------\n    centroid: the centroid of the bacterium\n    xc: the x-coordinate of the centroid\n    yc: the y-coordinate of the centroid\n    xc_nm: the x-coordinate of the centroid in nm\n    yc_nm: the y-coordinate of the centroid in nm\n    bbox: the bounding box of the bacterium\n    axis_major_length: the major axis length of the bacterium\n    axis_minor_length: the minor axis length of the bacterium\n    orientation: the orientation of the bacterium\n    area: the area of the bacterium\n    boundary: the boundary of the bacterium\n    medial_axis: the medial axis of the bacterium\n    medial_axis_extended: the medial axis of the bacterium extended to the boundary\n    slice: the slice of the stack where the bacterium is located (default is zero)\n    all_widths: the widths of the bacterium at different points along the medial axis\n    \"\"\"\n\n    def __init__(self, img, mask, options=dict()):\n        # print(\"New version!!\")\n        pxsize = options.get('pxsize', 1)\n        n_widths = options.get('n_widths', 5)\n        boundary_smoothing_factor = options.get('boundary_smoothing_factor', 8)\n        fit_type = options.get('fit_type', None)\n        psfFWHM = options.get('psfFWHM', 0.250)\n        error_threshold = options.get('error_threshold', 0.05)\n        max_iter = options.get('max_iter', 50)\n        min_distance_to_boundary = options.get('min_distance_to_boundary', 1)\n        step_size = options.get('step_size', 1)\n\n        # TODO: add to GUI!\n        spline_spacing = options.get('spline_spacing', 0.25)\n        spline_val = options.get('spline_val', 3)\n\n\n        # Get properties from regionprops, then add them to the class.\n        bacteria_props = regionprops(label(mask))\n\n        self.centroid = np.asarray(bacteria_props[0].centroid)\n        self.xc = bacteria_props[0].centroid[1]\n        self.yc = bacteria_props[0].centroid[0]\n        self.xc_nm = self.xc * pxsize\n        self.yc_nm = self.yc * pxsize\n        self.bbox = bacteria_props[0].bbox\n        self.axis_major_length = bacteria_props[0].major_axis_length * pxsize\n        self.axis_minor_length = bacteria_props[0].minor_axis_length * pxsize\n        self.orientation = bacteria_props[0].orientation\n        self.area = bacteria_props[0].area * pxsize**2\n\n        # Apply filter to image to avoid possible issues when calculating width of bacteria in clumps.\n        # also, crop image to reduce computational time of erosion etc\n        bbox = self.bbox\n        mask_cropped = np.copy(mask[bbox[0]-1:bbox[2]+1, bbox[1]-1:bbox[3]+1])\n        image_cropped = np.copy(img[bbox[0]-1:bbox[2]+1, bbox[1]-1:bbox[3]+1])\n\n        if fit_type == 'phase':\n            # Apply mask to image\n            img_filtered = apply_mask_to_image(image_cropped, mask_cropped, method='max')\n        else:\n            # Apply mask to image\n            img_filtered = apply_mask_to_image(image_cropped, mask_cropped, method='min')\n\n        # img_filtered = apply_mask_to_image(image_cropped, mask_cropped)\n\n        # Calculate other properties with custom functions.\n        try:\n            self.boundary = get_bacteria_boundary(mask_cropped, boundary_smoothing_factor=boundary_smoothing_factor)\n            self.perimeter = np.sum(np.sqrt(np.sum(np.diff(self.boundary, axis=0)**2, axis=1))) * pxsize\n            self.circularity = (4 * np.pi * self.area) / (self.perimeter**2)\n\n            start_time_medial_ax = time.perf_counter()\n            self.medial_axis = smooth_medial_axis(get_medial_axis(mask_cropped), self.boundary,\n                                                  error_threshold=error_threshold, max_iter=max_iter,\n                                                  spline_val=spline_val, spline_spacing=spline_spacing)\n            end_time_medial_ax = time.perf_counter()\n            logging.debug(f\"Time taken to calculate medial axis: {end_time_medial_ax - start_time_medial_ax:.2f} \"\n                          f\"seconds\")\n\n            start_time_extend = time.perf_counter()\n            self.medial_axis_extended = extend_medial_axis(self.medial_axis, self.boundary,\n                                                           error_threshold=error_threshold, max_iter=max_iter,\n                                                           min_distance_to_boundary=min_distance_to_boundary,\n                                                           step_size=step_size)\n            end_time_extend = time.perf_counter()\n            logging.debug(f\"Time taken to extend medial axis: {end_time_extend - start_time_extend:.2f} seconds\")\n\n            start_time_widths = time.perf_counter()\n            logging.debug(f\"Calculating widths using method {fit_type}\")\n            self.all_widths = get_bacteria_widths(img_filtered,\n                                                  self.medial_axis,\n                                                  n_lines=n_widths, pxsize=pxsize, fit_type=fit_type,\n                                                  line_magnitude=bacteria_props[0].axis_minor_length*1.5,\n                                                  psfFWHM=psfFWHM)\n            end_time_widths = time.perf_counter()\n            logging.debug(f\"Time taken to calculate widths: {end_time_widths - start_time_widths:.2f} seconds\")\n\n            self.width = np.median(self.all_widths)\n            if self.width &lt; 0:\n                self.width = None\n            self.length = get_bacteria_length(self.medial_axis_extended, pxsize)\n\n            # logging.debug(f\"Width: {self.width:.2f} nm from {self.all_widths}\")\n            # logging.debug(f\"Length: {self.length:.2f} nm\")\n            # TODO: improve how errors are dealt with\n        except ValueError:\n            logging.debug(\"Error calculating widths or length-VALUE\")\n            self.medial_axis = None\n            self.medial_axis_extended = None\n            self.all_widths = None\n            self.width = None\n            self.length = None\n        except IndexError:\n            logging.debug(\"Error calculating widths or length-INDEX\")\n            self.medial_axis = None\n            self.medial_axis_extended = None\n            self.all_widths = None\n            self.width = None\n            self.length = None\n\n        # Set slice to zero, this gets updated if the image is part of a stack outside of this function.\n        self.slice = 0\n</code></pre>"},{"location":"API/bacteria/#micromorph.bacteria.Bacteria.get_bacteria_for_index","title":"<code>get_bacteria_for_index(img: np.array, mask: np.array, i: int, options: dict)</code>","text":"<p>Function which returns a Bacteria object for the i-th bacterium in the labelled mask.</p> <p>Parameters:</p> Name Type Description Default <code>img</code> <code>np.array</code> <p>the image containing all the bacteria</p> required <code>mask</code> <code>np.array</code> <p>the labelled mask of the image</p> required <code>i</code> <code>int</code> <p>the index of the bacterium to be analysed</p> required <code>options</code> <code>dict</code> <p>a dictionary with options to be passed to the functions used to calculate the morphological properties of the bacterium</p> required <p>Returns:</p> Name Type Description <code>bac</code> <code>Bacteria</code> <p>a Bacteria object containing the properties of the i-th bacterium</p> Source code in <code>src\\micromorph\\bacteria\\Bacteria.py</code> <pre><code>def get_bacteria_for_index(img: np.array, mask: np.array, i: int, options: dict):\n    \"\"\"\n    Function which returns a Bacteria object for the i-th bacterium in the labelled mask.\n\n    Parameters\n    ----------\n    img: np.array\n        the image containing all the bacteria\n    mask: np.array\n        the labelled mask of the image\n    i: int\n        the index of the bacterium to be analysed\n    options: dict\n        a dictionary with options to be passed to the functions used to calculate the morphological properties of\n        the bacterium\n\n    Returns\n    -------\n    bac: Bacteria\n        a Bacteria object containing the properties of the i-th bacterium\n    \"\"\"\n    mask_current = np.copy(mask) == i\n\n    bac = Bacteria(img, mask_current, options)\n    bac.label = i\n\n    return bac\n</code></pre>"},{"location":"API/fitting_methods/","title":"Width Fitting","text":"<p><code>napari-bactmeasure</code> provides two fitting methods to calculate the width of a given bacterium, which have been  developed to work with either fluorescence or phase contrast microscopy images.</p>"},{"location":"API/fitting_methods/#fluorescence-microscopy-fitting-method","title":"Fluorescence microscopy fitting method","text":""},{"location":"API/fitting_methods/#micromorph.bacteria.fluorescence_fitting.fit_ring_profile","title":"<code>fit_ring_profile(x: np.array, y: np.array, psfFWHM: float)</code>","text":"<p>Fit the ring profile using a tilted circle model.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>np.array</code> <p>values at which the model is evaluated</p> required <code>y</code> <code>np.array</code> <p>measured ring profile</p> required <code>psfFWHM</code> <code>float</code> <p>the FWHM of the microscope PSF, in the unit of x_values</p> required <p>Returns:</p> Name Type Description <code>result</code> <code>lmfit.model.ModelResult</code> <p>the result of the fitting</p> Source code in <code>src\\micromorph\\bacteria\\fluorescence_fitting.py</code> <pre><code>def fit_ring_profile(x: np.array, y: np.array, psfFWHM: float):\n    \"\"\"\n    Fit the ring profile using a tilted circle model.\n\n    Parameters\n    ----------\n    x: np.array\n        values at which the model is evaluated\n    y: np.array\n        measured ring profile\n    psfFWHM: float\n        the FWHM of the microscope PSF, in the unit of x_values\n\n    Returns\n    -------\n    result: lmfit.model.ModelResult\n        the result of the fitting\n    \"\"\"\n    # Prepare the data\n    y = prepare_data(y)\n\n    # upscale the data - helps with ring fitting\n    n = 10\n    x_upscaled = np.linspace(np.min(x), np.max(x), len(x) * n)\n    y_upscaled = np.interp(x_upscaled, x, y)\n\n    # Get initial guess for the parameters\n    initial_guess = get_initial_guess(x_upscaled, y_upscaled)\n\n    # Create the model\n    gmodel = Model(ring_profile)\n\n    # Set the parameters\n    params = gmodel.make_params(x0=initial_guess['x0'],\n                                R=initial_guess['R'],\n                                offset=initial_guess['offset'],\n                                amp=initial_guess['amp'],\n                                psfFWHM=psfFWHM)\n\n    # Fix the psfFWHM\n    params['psfFWHM'].vary = False\n\n    # Fit the model\n    result = gmodel.fit(y_upscaled, params, x=x_upscaled)\n    return result\n</code></pre>"},{"location":"API/fitting_methods/#micromorph.bacteria.fluorescence_fitting.gaussian","title":"<code>gaussian(params: tuple or list, x: np.array) -&gt; np.array</code>","text":"<p>Gaussian function with 1 peak.</p> <p>Parameters:</p> Name Type Description Default <code>params</code> <code>tuple or list</code> <p>parameters of the gaussian function [centre, sigma]</p> required <code>x</code> <code>np.array</code> <p>values at which the model is evaluated</p> required <p>Returns:</p> Name Type Description <code>values</code> <code>np.array</code> <p>value(s) of the gaussian at x</p> Source code in <code>src\\micromorph\\bacteria\\fluorescence_fitting.py</code> <pre><code>def gaussian(params: tuple or list, x: np.array) -&gt; np.array:\n    \"\"\"\n    Gaussian function with 1 peak.\n\n    Parameters\n    ----------\n    params: tuple or list\n        parameters of the gaussian function [centre, sigma]\n    x: np.array\n        values at which the model is evaluated\n\n    Returns\n    -------\n    values: np.array\n        value(s) of the gaussian at x\n    \"\"\"\n\n    a0 = params[0]\n    a1 = params[1]\n\n    # values = np.exp(-(x - a0) ** 2 / (a1 ** 2)) / (a1 * np.sqrt(2 * np.pi))\n    values = np.exp(-(x - a0) ** 2 / (a1 ** 2))\n    return values\n</code></pre>"},{"location":"API/fitting_methods/#micromorph.bacteria.fluorescence_fitting.get_initial_guess","title":"<code>get_initial_guess(x: np.array, y: np.array)</code>","text":"<p>Get initial guess for ring profile model.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>np.array</code> <p>values at which the model is evaluated</p> required <code>y</code> <code>np.array</code> <p>measured ring profile</p> required <p>Returns:</p> Name Type Description <code>initial_guess</code> <code>dict</code> <p>initial guess for the parameters, in a dictionary</p> Source code in <code>src\\micromorph\\bacteria\\fluorescence_fitting.py</code> <pre><code>def get_initial_guess(x: np.array, y: np.array):\n    \"\"\"\n    Get initial guess for ring profile model.\n\n    Parameters\n    ----------\n    x: np.array\n        values at which the model is evaluated\n    y: np.array\n        measured ring profile\n\n    Returns\n    -------\n    initial_guess: dict\n        initial guess for the parameters, in a dictionary\n    \"\"\"\n    # Determine initial guess for the parameters\n    amplitude_guess = np.max(y)\n    bg_guess = np.min(y)\n\n    # x0 is the middle position\n    x0_guess = x[len(x) // 2]\n\n    # find location minimum in first half of the data\n    min_loc = x[np.argmax(y[:len(y) // 2])]\n    # find location of maximum in second half of the data\n    max_loc = x[(np.argmax(y[len(y) // 2:]) + len(y) // 2)]\n\n    # print(max_loc - min_loc)\n    width_guess = (max_loc - min_loc) / 2  # this could possibly be determined from the FWHM of the peak\n\n    initial_guess = {'x0': x0_guess, 'R': width_guess, 'offset': bg_guess, 'amp': amplitude_guess}\n\n    return initial_guess\n</code></pre>"},{"location":"API/fitting_methods/#micromorph.bacteria.fluorescence_fitting.prepare_data","title":"<code>prepare_data(profile: np.array) -&gt; np.array</code>","text":"<p>Prepare the data for fitting, normalising the profile.</p> <p>Parameters:</p> Name Type Description Default <code>profile</code> <code>np.array</code> <p>the profile to be prepared</p> required <p>Returns:</p> Name Type Description <code>profile</code> <code>np.array</code> <p>the normalised profile</p> Source code in <code>src\\micromorph\\bacteria\\fluorescence_fitting.py</code> <pre><code>def prepare_data(profile: np.array)-&gt; np.array:\n    \"\"\"\n    Prepare the data for fitting, normalising the profile.\n\n    Parameters\n    ----------\n    profile: np.array\n        the profile to be prepared\n\n    Returns\n    -------\n    profile: np.array\n        the normalised profile\n    \"\"\"\n    # Normalise the profile\n    profile = profile / np.max(profile)\n\n\n    return profile\n</code></pre>"},{"location":"API/fitting_methods/#micromorph.bacteria.fluorescence_fitting.ring_profile","title":"<code>ring_profile(x: np.array, psfFWHM: int or float, R: int or float, x0: int or float, offset: int or float, amp: int or float) -&gt; np.array</code>","text":"<p>This function produces a line profile of a septum using an explicit 'tilted circle' model. It is based off code written in MATLAB by S\u00e9amus Holden, described in Whitley et al. 2021 and hosted in </p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>np.array</code> <p>values at which the model is evaluated</p> required <code>x0</code> <code>int or float</code> <p>the centre of the ring</p> required <code>R</code> <code>int or float</code> <p>the radius of the ring</p> required <code>psfFWHM</code> <code>int or float</code> <p>the FWHM of the microscope PSF, in the unit of x_values</p> required <code>offset</code> <code>int or float</code> <p>the background value</p> required <code>amp</code> <code>int or float</code> <p>the amplitude of the ring profile</p> required <p>Returns:</p> Name Type Description <code>image_profile</code> <code>np.array</code> <p>value(s) of the ring profile at x</p> Source code in <code>src\\micromorph\\bacteria\\fluorescence_fitting.py</code> <pre><code>def ring_profile(x: np.array, \n                 psfFWHM: int or float, \n                 R: int or float, \n                 x0: int or float, \n                 offset: int or float,\n                 amp: int or float) -&gt; np.array:\n    \"\"\"\n    This function produces a line profile of a septum using an explicit 'tilted circle' model.\n    It is based off code written in MATLAB by S\u00e9amus Holden, described in [Whitley et al. 2021](\n    https://www.nature.com/articles/s41467-021-22526-0) and hosted in \n\n    Parameters\n    ----------\n    x: np.array\n        values at which the model is evaluated\n    x0: float\n        the centre of the ring\n    R: float\n        the radius of the ring\n    psfFWHM: float\n        the FWHM of the microscope PSF, in the unit of x_values\n    offset: float\n        the background value\n    amp: float\n        the amplitude of the ring profile\n\n    Returns\n    -------\n    image_profile: np.array\n        value(s) of the ring profile at x\n    \"\"\"\n    # n = 10\n    # x_original = np.copy(x) # new\n    # x = np.linspace(np.min(x), np.max(x), len(x) * n) # new\n    # Calculate the sigma (standard deviation) of the PSF\n    sigma = psfFWHM / 2.35\n\n    x_extended = np.insert(x, 0, 0)\n\n    profile_integral = 2 * R * np.real(np.emath.arcsin((x_extended - x0) / R))\n\n    image_profile = np.diff(profile_integral)\n\n    # # add zero to the beginning of the array\n    # image_profile = np.insert(image_profile, 0, 0)\n\n    # Convolution with gaussian function\n    gauss_profile = gaussian([0, sigma], profile_integral)\n    # gauss_profile = np.insert(gauss_profile, 0, 0)\n    image_profile = convolve(image_profile, gauss_profile, mode='same')\n\n    # image_profile = image_profile / np.max(image_profile) # temp\n    image_profile = image_profile * amp + offset\n\n    # calculate center of mass of image_profile\n    com_profile = np.average(x, weights=image_profile)\n\n    index_x0 = np.argmin(np.abs(x - x0))\n    index_com = np.argmin(np.abs(x - com_profile))\n\n    # shift the profile to the center of mass\n    image_profile = np.roll(image_profile, - index_x0 + index_com)\n\n    # image_profile_original = np.copy(image_profile) # new\n    # image_profile = image_profile[::n] # new\n    # image_profile_interp = np.interp(x_original, x, image_profile)\n    return image_profile\n</code></pre>"},{"location":"API/fitting_methods/#phase-contrast-microscopy-fitting-method","title":"Phase contrast microscopy fitting method","text":""},{"location":"API/fitting_methods/#micromorph.bacteria.phase_contrast_fitting.fit_phase_contrast_profile","title":"<code>fit_phase_contrast_profile(x: np.array, y: np.array)</code>","text":"<p>Fit the phase contrast profile using a super gaussian (top-hat) model.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>np.array</code> <p>x (independent) values of the profile</p> required <code>y</code> <code>np.array</code> <p>y values of the profile - this is what gets fitted</p> required <p>Returns:</p> Name Type Description <code>result</code> <code>lmfit object</code> <p>the result of the fitting process, see lmfit documentation for more details</p> Source code in <code>src\\micromorph\\bacteria\\phase_contrast_fitting.py</code> <pre><code>def fit_phase_contrast_profile(x: np.array, y: np.array):\n    \"\"\"\n    Fit the phase contrast profile using a super gaussian (top-hat) model.\n\n    Parameters\n    ----------\n    x: np.array\n        x (independent) values of the profile\n\n    y: np.array\n        y values of the profile - this is what gets fitted\n\n    Returns\n    -------\n    result : lmfit object\n        the result of the fitting process, see lmfit documentation for more details\n    \"\"\"\n    # Invert the profile\n    y = invert_profile(y)\n\n    # Get initial guess for the parameters\n    initial_guess = get_initial_guess(x, y)\n\n    # Create the model\n    gmodel = Model(super_gaussian)\n\n    # Set the parameters\n    params = gmodel.make_params(center=initial_guess['center'],\n                                width=initial_guess['width'],\n                                amplitude=initial_guess['amplitude'],\n                                order=4,\n                                offset=initial_guess['offset'])\n\n    # fix order\n    params['order'].vary = False\n    params['width'].min = 0\n\n\n    # Fit the model\n    result = gmodel.fit(y, params, x=x, nan_policy='raise')\n\n    return result\n</code></pre>"},{"location":"API/fitting_methods/#micromorph.bacteria.phase_contrast_fitting.fit_top_hat_profile","title":"<code>fit_top_hat_profile(x: np.array, y: np.array)</code>","text":"<p>Fit the phase contrast profile using a super gaussian (top-hat) model.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>np.array</code> <p>x (independent) values of the profile</p> required <code>y</code> <code>np.array</code> <p>y values of the profile - this is what gets fitted</p> required <p>Returns:</p> Name Type Description <code>result</code> <code>lmfit object</code> <p>the result of the fitting process, see lmfit documentation for more details</p> Source code in <code>src\\micromorph\\bacteria\\phase_contrast_fitting.py</code> <pre><code>def fit_top_hat_profile(x: np.array, y: np.array):\n    \"\"\"\n    Fit the phase contrast profile using a super gaussian (top-hat) model.\n\n    Parameters\n    ----------\n    x: np.array\n        x (independent) values of the profile\n\n    y: np.array\n        y values of the profile - this is what gets fitted\n\n    Returns\n    -------\n    result : lmfit object\n        the result of the fitting process, see lmfit documentation for more details\n    \"\"\"\n    # Invert the profile\n    # y = invert_profile(y)\n\n    # Get initial guess for the parameters\n    initial_guess = get_initial_guess(x, y)\n\n    # Create the model\n    gmodel = Model(super_gaussian)\n\n    # Set the parameters\n    params = gmodel.make_params(center=initial_guess['center'],\n                                width=initial_guess['width'],\n                                amplitude=initial_guess['amplitude'],\n                                order=4,\n                                offset=initial_guess['offset'])\n\n    # fix order\n    params['order'].vary = False\n\n    # Fit the model\n    result = gmodel.fit(y, params, x=x, nan_policy='raise')\n    return result\n</code></pre>"},{"location":"API/fitting_methods/#micromorph.bacteria.phase_contrast_fitting.get_initial_guess","title":"<code>get_initial_guess(x: np.array, y: np.array) -&gt; dict</code>","text":"<p>Get the initial guess for super gaussian model.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>np.array</code> <p>values at which the model is evaluated</p> required <code>y</code> <code>np.array</code> <p>measured phase contrast profile</p> required <p>Returns:</p> Name Type Description <code>initial_guess</code> <code>dict</code> <p>initial guess for the parameters, in a dictionary</p> Source code in <code>src\\micromorph\\bacteria\\phase_contrast_fitting.py</code> <pre><code>def get_initial_guess(x: np.array, y: np.array) -&gt; dict:\n    \"\"\"\n    Get the initial guess for super gaussian model.\n\n    Parameters\n    ----------\n    x: np.array\n        values at which the model is evaluated\n    y: np.array\n        measured phase contrast profile\n\n    Returns\n    -------\n    initial_guess: dict\n        initial guess for the parameters, in a dictionary\n    \"\"\"\n    # Determine initial guess for the parameters\n    amplitude_guess = np.max(y)\n    offset_guess = np.min(y)\n\n    # find location minimum in first half of the data\n    min_loc = x[np.argmin(y[:len(y) // 2])]\n    # find location of minimum in second half of the data\n    max_loc = x[(np.argmin(y[len(y) // 2:]) + len(y) // 2)]\n\n    center_guess = (max_loc + min_loc) / 2\n\n    width_guess = (max_loc - min_loc) / 2\n\n    # Store all the initial guesses in a dictionary\n    initial_guess = {'center': center_guess, 'width': width_guess, 'amplitude': amplitude_guess, 'offset': offset_guess}\n\n    return initial_guess\n</code></pre>"},{"location":"API/fitting_methods/#micromorph.bacteria.phase_contrast_fitting.invert_profile","title":"<code>invert_profile(profile: np.array) -&gt; np.array</code>","text":"<p>Convenience function to invert the profile to make it more suitable for fitting.</p> <p>Parameters:</p> Name Type Description Default <code>profile</code> <code>np.array</code> <p>the profile to be inverted</p> required <p>Returns:</p> Name Type Description <code>profile</code> <code>np.array</code> <p>the inverted profile</p> Source code in <code>src\\micromorph\\bacteria\\phase_contrast_fitting.py</code> <pre><code>def invert_profile(profile: np.array) -&gt; np.array:\n    \"\"\"\n    Convenience function to invert the profile to make it more suitable for fitting.\n\n    Parameters\n    ----------\n    profile: np.array\n        the profile to be inverted\n\n    Returns\n    -------\n    profile: np.array\n        the inverted profile\n    \"\"\"\n    # Invert the profile\n    profile = np.max(profile) - profile\n\n    return profile\n</code></pre>"},{"location":"API/fitting_methods/#micromorph.bacteria.phase_contrast_fitting.super_gaussian","title":"<code>super_gaussian(x: np.array, center: float, width: float, amplitude: float, order: float or int, offset: float or int) -&gt; np.array</code>","text":"<p>Super Gaussian model (top hat) to be used for fitting phase contrast profiles.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>np.array</code> <p>values at which the model is evaluated</p> required <code>center</code> <code>float</code> <p>center of the super gaussian</p> required <code>width</code> <code>float</code> <p>width of the super gaussian</p> required <code>amplitude</code> <code>float</code> <p>amplitude of the super gaussian</p> required <code>order</code> <code>float or int</code> <p>order of the super gaussian (makes it more or less top-hat shaped)</p> required <code>offset</code> <code>float or int</code> <p>offset of the super gaussian (background)</p> required <p>Returns:</p> Name Type Description <code>value</code> <code>np.array</code> <p>value(s) of the super gaussian at x</p> Source code in <code>src\\micromorph\\bacteria\\phase_contrast_fitting.py</code> <pre><code>def super_gaussian(x: np.array, center: float, width: float, amplitude: float, order: float or int, offset: float or\n    int) -&gt; np.array:\n    \"\"\"\n    Super Gaussian model (top hat) to be used for fitting phase contrast profiles.\n\n    Parameters\n    ----------\n    x: np.array\n        values at which the model is evaluated\n    center: float\n        center of the super gaussian\n    width: float\n        width of the super gaussian\n    amplitude: float\n        amplitude of the super gaussian\n    order: int\n        order of the super gaussian (makes it more or less top-hat shaped)\n    offset: float\n        offset of the super gaussian (background)\n\n    Returns\n    -------\n    value: np.array\n        value(s) of the super gaussian at x\n    \"\"\"\n\n    value = np.exp(-2*((x - center) / width) ** (order)) * amplitude + offset\n    if np.isnan(value).any():\n        print(f'nan value found for x={x}, center={center}, width={width}, order={1}, amplitude={amplitude}')\n    return value\n</code></pre>"},{"location":"API/measure360/","title":"Measure360","text":""},{"location":"API/measure360/#micromorph.measure360.measure360.Bacteria360","title":"<code>Bacteria360</code>","text":"<p>A class to store all the properties of a single bacterium. It requires an image and a mask to be initialised, which are used to calculate the properties.</p> <p>Parameters:</p> Name Type Description Default <code>img</code> <code>np.array</code> <p>The image of the bacterium.</p> required <code>centroid</code> <code>tuple</code> <p>The centroid of the bacterium.</p> required <code>options</code> <code>dict</code> <p>Dictionary of options to pass to the measure360 function.</p> <code>dict()</code> <p>Attributes:</p> Name Type Description <code>centroid</code> <code>tuple</code> <p>The centroid of the bacterium.</p> <code>width_data</code> <code>np.array</code> <p>The width data of the bacterium.</p> <code>width</code> <code>float</code> <p>The minimum width of the bacterium.</p> <code>length</code> <code>float</code> <p>The maximum width of the bacterium.</p> <code>area</code> <code>float</code> <p>The area of the bacterium.</p> <code>label</code> <code>int</code> <p>The label of the bacterium.</p> <code>bbox</code> <code>tuple</code> <p>The bounding box of the bacterium.</p> <code>slice</code> <code>int</code> <p>The slice of the stack the bacterium is from.</p> <code>n_lines</code> <code>int</code> <p>The number of lines to measure the width along.</p> <code>magnitude</code> <code>float</code> <p>The length of the lines.</p> <code>px_size</code> <code>float</code> <p>The pixel size of the image.</p> <code>psfFWHM</code> <code>float</code> <p>The FWHM of the PSF.</p> <code>xc</code> <code>float</code> <p>The x-coordinate of the centroid.</p> <code>yc</code> <code>float</code> <p>The y-coordinate of the centroid.</p> <code>xc_nm</code> <code>float</code> <p>The x-coordinate of the centroid in nm.</p> <code>yc_nm</code> <code>float</code> <p>The y-coordinate of the centroid in nm.</p> Source code in <code>src\\micromorph\\measure360\\measure360.py</code> <pre><code>class Bacteria360:\n    \"\"\"\n    A class to store all the properties of a single bacterium.\n    It requires an image and a mask to be initialised, which are used to calculate the properties.\n\n    Parameters\n    ----------\n    img : np.array\n        The image of the bacterium.\n    centroid : tuple\n        The centroid of the bacterium.\n    options : dict\n        Dictionary of options to pass to the measure360 function.\n\n    Attributes\n    ----------\n    centroid : tuple\n        The centroid of the bacterium.\n    width_data : np.array\n        The width data of the bacterium.\n    width : float\n        The minimum width of the bacterium.\n    length : float\n        The maximum width of the bacterium.\n    area : float\n        The area of the bacterium.\n    label : int\n        The label of the bacterium.\n    bbox : tuple\n        The bounding box of the bacterium.\n    slice : int\n        The slice of the stack the bacterium is from.\n    n_lines : int\n        The number of lines to measure the width along.\n    magnitude : float\n        The length of the lines.\n    px_size : float\n        The pixel size of the image.\n    psfFWHM : float\n        The FWHM of the PSF.\n    xc : float\n        The x-coordinate of the centroid.\n    yc : float\n        The y-coordinate of the centroid.\n    xc_nm : float\n        The x-coordinate of the centroid in nm.\n    yc_nm : float\n        The y-coordinate of the centroid in nm.\n\n    \"\"\"\n    def __init__(self, img, centroid, options=dict()):\n\n        n_lines = options.get('n_lines', 50)\n        magnitude = options.get('magnitude', 100)\n        pool = options.get('pool', None)\n        area = options.get('area', 0)\n        label = options.get('label', None)\n        bbox = options.get('bbox', None)\n\n        width_data = np.array(measure360(img, centroid, options=options))\n\n        # remove any rows containing nan values\n        width_data = width_data[~np.isnan(width_data).any(axis=1)]\n\n        self.centroid = centroid\n        self.width_data = width_data\n        self.width = np.min(self.width_data[:, 1])\n        self.length = np.max(self.width_data[:, 1])\n        self.area = area\n        self.label = label\n        self.bbox = bbox\n        self.slice = 0  # this is by default 0, but gets overwritten when data is generated from a stack\n\n        self.n_lines = n_lines\n        self.magnitude = magnitude\n        self.px_size = options.get('px_size', None)\n        self.psfFWHM = options.get('psfFWHM', None)\n\n        self.xc = centroid[0]\n        self.yc = centroid[1]\n\n        self.xc_nm = self.xc * options.get('px_size', 1)\n        self.yc_nm = self.yc * options.get('px_size', 1)\n</code></pre>"},{"location":"API/measure360/#micromorph.measure360.measure360.filter_measure360","title":"<code>filter_measure360(bacteria, filter_type, filter_settings)</code>","text":"<p>Function to filter the width data of a bacterium.</p> <p>Parameters:</p> Name Type Description Default <code>bacteria</code> <code>Bacteria360</code> <p>The Bacteria360 object to be filtered.</p> required <code>filter_type</code> <code>str</code> <p>The type of filter to apply. Options are 'stdev', 'derivative' or 'sav-gol'.</p> required <code>filter_settings</code> <code>list</code> <p>The settings for the filter. For 'stdev' and 'derivative' this is a single value, for 'sav-gol' it is a list of two values [window, order].</p> required <p>Returns:</p> Name Type Description <code>bacteria</code> <code>Bacteria360</code> <p>The Bacteria360 object with the filtered width data.</p> Source code in <code>src\\micromorph\\measure360\\measure360.py</code> <pre><code>def filter_measure360(bacteria, filter_type, filter_settings):\n    \"\"\"\n    Function to filter the width data of a bacterium.\n\n    Parameters\n    ----------\n    bacteria : Bacteria360\n        The Bacteria360 object to be filtered.\n    filter_type : str\n        The type of filter to apply. Options are 'stdev', 'derivative' or 'sav-gol'.\n    filter_settings : list\n        The settings for the filter. For 'stdev' and 'derivative' this is a single value, for 'sav-gol' it is a list\n        of two values [window, order].\n\n    Returns\n    -------\n    bacteria : Bacteria360\n        The Bacteria360 object with the filtered width data.\n    \"\"\"\n    width_data = np.copy(bacteria.width_data[:, 1])\n\n    if filter_type == 'stdev':\n        # Filter the width\n        idx = abs(width_data - np.median(width_data)) &lt; filter_settings[0] * np.std(width_data)\n\n        bacteria.width_data = bacteria.width_data[idx, :]\n    elif filter_type == 'derivative':\n        delta = np.diff(width_data)\n        delta = np.insert(delta, 0, 0)\n        idx = abs(delta) &lt; filter_settings[0]\n\n        bacteria.width_data = bacteria.width_data[idx, :]\n    elif filter_type == 'sav-gol':\n        window = filter_settings[0]\n        order = filter_settings[1]\n        width_data = savgol_filter(width_data, window, order)\n        bacteria.width_data[:, 1] = width_data\n\n    try:\n        bacteria.width = np.min(bacteria.width_data[:, 1])\n        bacteria.length = np.max(bacteria.width_data[:, 1])\n    except:\n        print(\"filtering didn't work\")\n\n    return bacteria\n</code></pre>"},{"location":"API/measure360/#micromorph.measure360.measure360.fit_multiprocessing","title":"<code>fit_multiprocessing(img, angle, x_1, y_1, x_2, y_2, params)</code>","text":"<p>Function to fit the width of the bacterium at a single angle.</p> <p>Parameters:</p> Name Type Description Default <code>img</code> <code>np.array</code> <p>The image of the bacterium.</p> required <code>angle</code> <code>float</code> <p>The angle corresponding to the line. It is stores in the results array but has no bearing on the width calculation.</p> required <code>x_1</code> <code>float</code> <p>The x-coordinate of the start of the line.</p> required <code>y_1</code> <code>float</code> <p>The y-coordinate of the start of the line.</p> required <code>x_2</code> <code>float</code> <p>The x-coordinate of the end of the line.</p> required <code>y_2</code> <code>float</code> <p>The y-coordinate of the end of the line.</p> required <code>params</code> <code>list</code> <p>List of parameters [psfFWHM, pxsize, fit_type].</p> required <p>Returns:</p> Name Type Description <code>data</code> <code>np.array</code> <p>Array of data [angle, width, x_1, y_1, x_2, y_2].</p> Source code in <code>src\\micromorph\\measure360\\measure360.py</code> <pre><code>def fit_multiprocessing(img, angle, x_1, y_1, x_2, y_2, params):\n    \"\"\"\n    Function to fit the width of the bacterium at a single angle.\n\n    Parameters\n    ----------\n    img : np.array\n        The image of the bacterium.\n    angle : float\n        The angle corresponding to the line. It is stores in the results array but has no bearing on the width\n        calculation.\n    x_1 : float\n        The x-coordinate of the start of the line.\n    y_1 : float\n        The y-coordinate of the start of the line.\n    x_2 : float\n        The x-coordinate of the end of the line.\n    y_2 : float\n        The y-coordinate of the end of the line.\n    params : list\n        List of parameters [psfFWHM, pxsize, fit_type].\n\n    Returns\n    -------\n    data : np.array\n        Array of data [angle, width, x_1, y_1, x_2, y_2].\n    \"\"\"\n\n    psfFWHM = params[0]\n    pxsize = params[1]\n    fit_type = params[2]\n\n    # Set up array to collect data\n    current_profile = profile_line(img, (y_1, x_1), (y_2, x_2))\n\n    x = np.arange(0, len(current_profile)) * pxsize\n\n    try:\n        if fit_type == 'fluorescence':\n            result = fit_ring_profile(x, current_profile, psfFWHM)\n            width = result.params['R'] * 2\n        elif fit_type == 'phase':\n            result = fit_phase_contrast_profile(x, current_profile)\n            width = result.params['width'].value\n        elif fit_type == 'tophat':\n            result = fit_top_hat_profile(x, current_profile)\n            width = result.params['width'].value\n        else:\n            raise ValueError('Invalid fit type - please choose \"fluorescence\" or \"phase\".')\n    except:\n        width = np.nan\n\n    if width &lt; 0:\n        width = np.nan\n\n    data = np.array([angle, width, x_1, y_1, x_2, y_2])\n\n    return data\n</code></pre>"},{"location":"API/measure360/#micromorph.measure360.measure360.get_points_on_circle","title":"<code>get_points_on_circle(centroid, magnitude, angle_range)</code>","text":"<p>Function to get the points on a circle of a given radius around a centroid.</p> <p>Parameters:</p> Name Type Description Default <code>centroid</code> <code>tuple</code> <p>The centroid of the bacterium.</p> required <code>magnitude</code> <code>float</code> <p>The radius of the circle.</p> required <code>angle_range</code> <code>np.array</code> <p>The range of angles to calculate the points.</p> required <p>Returns:</p> Name Type Description <code>x_1</code> <code>np.array</code> <p>The x-coordinates of the start of the lines.</p> <code>y_1</code> <code>np.array</code> <p>The y-coordinates of the start of the lines.</p> <code>x_2</code> <code>np.array</code> <p>The x-coordinates of the end of the lines.</p> <code>y_2</code> <code>np.array</code> <p>The y-coordinates of the end of the lines.</p> Source code in <code>src\\micromorph\\measure360\\measure360.py</code> <pre><code>def get_points_on_circle(centroid, magnitude, angle_range):\n    \"\"\"\n    Function to get the points on a circle of a given radius around a centroid.\n\n    Parameters\n    ----------\n    centroid : tuple\n        The centroid of the bacterium.\n    magnitude : float\n        The radius of the circle.\n    angle_range : np.array\n        The range of angles to calculate the points.\n\n    Returns\n    -------\n    x_1 : np.array\n        The x-coordinates of the start of the lines.\n    y_1 : np.array\n        The y-coordinates of the start of the lines.\n    x_2 : np.array\n        The x-coordinates of the end of the lines.\n    y_2 : np.array\n        The y-coordinates of the end of the lines.\n    \"\"\"\n    x_1 = centroid[1] + magnitude*np.cos(angle_range)\n    y_1 = centroid[0] + magnitude*np.sin(angle_range)\n\n    x_2 = centroid[1] - magnitude*np.cos(angle_range)\n    y_2 = centroid[0] - magnitude*np.sin(angle_range)\n\n    return x_1, y_1, x_2, y_2\n</code></pre>"},{"location":"API/measure360/#micromorph.measure360.measure360.measure360","title":"<code>measure360(img, centroid, options=dict())</code>","text":"<p>This function measures the width of a bacterium at 360 degrees around its centroid.</p> <p>Parameters:</p> Name Type Description Default <code>img</code> <code>np.array</code> <p>The image of the bacterium.</p> required <code>centroid</code> <code>tuple</code> <p>The centroid of the bacterium.</p> required <code>options</code> <code>dict</code> <p>Dictionary of options to pass to the measure360 function.</p> <code>dict()</code> <p>Returns:</p> Name Type Description <code>data</code> <code>list</code> <p>List of data [angle, width, x_1, y_1, x_2, y_2].</p> Source code in <code>src\\micromorph\\measure360\\measure360.py</code> <pre><code>def measure360(img, centroid, options=dict()):\n    \"\"\"\n    This function measures the width of a bacterium at 360 degrees around its centroid.\n\n    Parameters\n    ----------\n    img : np.array\n        The image of the bacterium.\n    centroid : tuple\n        The centroid of the bacterium.\n    options : dict\n        Dictionary of options to pass to the measure360 function.\n\n    Returns\n    -------\n    data : list\n        List of data [angle, width, x_1, y_1, x_2, y_2].\n    \"\"\"\n    n_lines = options.get('n_lines', 100)\n    magnitude = options.get('magnitude', 100)\n    psfFWHM = options.get('psfFWHM', 0.25)\n    px_size = options.get('pxsize', 0.65)\n    fit_type = options.get('fit_type', 'fluorescence')\n    pool = options.get('pool', None)\n    params = [psfFWHM, px_size, fit_type]\n\n    # # Initialise multi processing pool\n    # if pool is None:\n    #     # Number of processes to run in parallel\n    #     num_processes = multiprocessing.cpu_count()\n    #     # Create a pool of worker processes\n    #     pool = multiprocessing.Pool(processes=num_processes)\n\n    # Define angle_range based on required number of lines\n    angle_range = np.linspace(0, np.pi, n_lines)\n\n    # Get points on circle\n    x_1, y_1, x_2, y_2 = get_points_on_circle(centroid, magnitude/2, angle_range)\n\n    # Check if any x or y is below 0 or above the image size\n    x_1 = np.clip(x_1, 0, img.shape[1])\n    y_1 = np.clip(y_1, 0, img.shape[0])\n    x_2 = np.clip(x_2, 0, img.shape[1])\n    y_2 = np.clip(y_2, 0, img.shape[0])\n\n    data = []\n\n    start = time.time()\n\n    # possible way to run multiprocessing?\n#     with multiprocessing.Pool() as pool:\n#        data = pool.map(fit_multiprocessing, [(img, angle_range[i], x_1[i], y_1[i], x_2[i], y_2[i], params) for i in range(len(x_1))])\n    # data = pool.starmap(fit_multiprocessing, [(img, angle_range[i], x_1[i], y_1[i], x_2[i], y_2[i], params) for i in range(len(x_1))])\n\n    for i in range(len(x_1)):\n        # logging.debug(f'Processing line {i+1} of {len(x_1)}')\n        data.append(fit_multiprocessing(img, angle_range[i], x_1[i], y_1[i], x_2[i], y_2[i], params))\n\n    if options.get('verbose', False):\n        logging.debug('Time taken: ', time.time() - start)\n\n    return data\n</code></pre>"},{"location":"API/measure360/#micromorph.measure360.measure360.run_measure360","title":"<code>run_measure360(img: np.array, mask: np.array, options: dict = dict(), pool=None, close_pool=True)</code>","text":"<p>Runs the measure360 function on a single image or a stack of images.</p> <p>Parameters:</p> Name Type Description Default <code>img</code> <code>np.array</code> <p>Single frame (or stack), either phase contrast or fluorescence.</p> required <code>mask</code> <code>np.array</code> <p>Labelled mask from the image.</p> required <code>options</code> <code>dict</code> <p>Dictionary of options to pass to the measure360 function.</p> <code>dict()</code> <p>Returns:</p> Name Type Description <code>all_bacteria</code> <code>list</code> <p>List of Bacteria360 objects.</p> Source code in <code>src\\micromorph\\measure360\\measure360.py</code> <pre><code>def run_measure360(img: np.array, mask: np.array, options: dict = dict(), pool=None, close_pool=True):\n    \"\"\"\n    Runs the measure360 function on a single image or a stack of images.\n\n    Parameters\n    ----------\n    img : np.array\n        Single frame (or stack), either phase contrast or fluorescence.\n    mask : np.array\n        Labelled mask from the image.\n    options : dict, optional\n        Dictionary of options to pass to the measure360 function.\n\n    Returns\n    -------\n    all_bacteria : list\n        List of Bacteria360 objects.\n    \"\"\"\n    if pool is None:\n        logging.info(\"Making a pool for multithreading - this only happens once!\")\n        pool = ThreadPoolExecutor()  # Create executor outside a with block\n        logging.info(\"Pool created!\")\n    else:\n        logging.info(\"Using existing pool for multithreading\")\n\n    all_bacteria = []\n    if len(img.shape) == 2:\n        # Get bacteria properties\n        props = regionprops(mask)\n\n        args = [(img, mask, i, bact, options) for i, bact in enumerate(props)]\n\n        futures = [pool.submit(process_single_bacterium, arg) for arg in args]\n        with tqdm(total=len(args)) as pbar:\n            for future in as_completed(futures):\n                result = future.result()\n                all_bacteria.append(result)\n                pbar.update(1)\n    else:\n        n_frames = img.shape[0]\n        for i in range(n_frames):\n            # Get ith image and mask\n            img_current = np.copy(img[i])\n            mask_current = np.copy(mask[i])\n\n            current_data = run_measure360(img_current, mask_current, options=options, pool=pool, close_pool=False)\n\n            for bact in current_data:\n                bact.slice = i\n\n            all_bacteria.extend(current_data)\n\n    if close_pool:\n        if pool:\n            pool.shutdown(wait=True)\n\n    return all_bacteria\n</code></pre>"},{"location":"API/measure360/#micromorph.measure360.measure360.width_distribution","title":"<code>width_distribution(all_data)</code>","text":"<p>Convenience function to plot the distribution of the widths of all the bacteria.</p> <p>Parameters:</p> Name Type Description Default <code>all_data</code> <code>list</code> <p>List of Bacteria360 objects.</p> required <p>Returns:</p> Type Description <code>None</code> Source code in <code>src\\micromorph\\measure360\\measure360.py</code> <pre><code>def width_distribution(all_data):\n    \"\"\"\n    Convenience function to plot the distribution of the widths of all the bacteria.\n\n    Parameters\n    ----------\n    all_data : list\n        List of Bacteria360 objects.\n\n    Returns\n    -------\n    None\n    \"\"\"\n\n    all_widths = []\n\n    for data in all_data:\n        width = data.width\n        all_widths.append(width)\n\n    plt.hist(all_widths)\n    plt.show()\n    print(len(all_widths))\n</code></pre>"},{"location":"API/segmentation_utilities/","title":"Segmentation Utilities","text":"<p>This is a collection of wrapper functions for omnipose.</p> <p>Run the specified omnipose model on the input image(s)</p> <p>Parameters:</p> Name Type Description Default <code>images</code> <code>np.array</code> <p>The input image(s) to segment. If a single image is provided, it should be a 2D array. If multiple images are provided, they should be a 3D array with shape (n_images, height, width).</p> required <code>model_name</code> <code>str</code> <p>The name of the model to use.</p> required <code>gpu_option</code> <code>bool</code> <p>Whether to use the GPU for segmentation.</p> required <code>chans</code> <code>tuple or None</code> <p>The channels to use for segmentation. If None, the first channel will be used.</p> <code>None</code> <code>filter_options</code> <code>dict</code> <p>A dictionary containing the filter options for the segmentation. Related to the omnipose package. See this  link for more info: https://omnipose.readthedocs.io/examples/mono_channel_bact.html#run-segmentation</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>masks</code> <code>np.ndarray</code> <p>The segmented masks. If a single image is provided, it will be a 2D array. If multiple images are provided, it will be a 3D array with shape (n_images, height, width).</p> <code>flows</code> <code>np.ndarray</code> <p>The flow outputs. If a single image is provided, it will be a 2D array. If multiple images are provided, it will be a 3D array with shape (n_images, height, width).</p> Source code in <code>src\\micromorph\\segmentation\\segmentation_tools.py</code> <pre><code>def run_omnipose(images: np.array, model_name: str, gpu_option: bool, chans: tuple or None =None, filter_options:\ndict ={}) -&gt; Union[np.array, np.array]:\n    \"\"\"\n    Run the specified omnipose model on the input image(s)\n\n    Parameters\n    ----------\n    images: np.ndarray\n        The input image(s) to segment. If a single image is provided, it should be a 2D array. If multiple images are provided, they should be a 3D array with shape (n_images, height, width).\n    model_name: str\n        The name of the model to use.\n    gpu_option: bool\n        Whether to use the GPU for segmentation.\n    chans: tuple or None\n        The channels to use for segmentation. If None, the first channel will be used.\n    filter_options: dict\n        A dictionary containing the filter options for the segmentation. Related to the omnipose package. See this \n        link for more info: https://omnipose.readthedocs.io/examples/mono_channel_bact.html#run-segmentation\n\n    Returns\n    -------\n    masks: np.ndarray\n        The segmented masks. If a single image is provided, it will be a 2D array. If multiple images are provided, it will be a 3D array with shape (n_images, height, width).\n    flows: np.ndarray\n        The flow outputs. If a single image is provided, it will be a 2D array. If multiple images are provided, it will be a 3D array with shape (n_images, height, width).\n    \"\"\"\n    # Should also add to this function the possibility to:\n    model = models.CellposeModel(gpu=gpu_option, model_type=model_name)\n\n    if chans is None:\n        chans = [0, 0]  # If user didn't specify a channel, assume you need to use the first channel\n\n    # TODO: params should be a dictionary which you can edit\n\n    # define parameters - this is to become an input parameter\n    params = {'channels': chans,  # always define this with the model\n              'rescale': None,  # upscale or downscale your images, None = no rescaling\n              'mask_threshold': 1,  # erode or dilate masks with higher or lower values -1\n              'flow_threshold': 0.2,\n              # default is .4, but only needed if there are spurious masks to clean up; slows down output\n              'transparency': True,  # transparency in flow output\n              'omni': True,  # we can turn off Omnipose mask reconstruction, not advised\n              'cluster': True,  # use DBSCAN clustering\n              'resample': True,  # whether to run dynamics on rescaled grid or original grid\n              # 'verbose': False, # turn on if you want to see more output\n              'tile': False,  # average the outputs from flipped (augmented) images; slower, usually not needed\n              'niter': None,\n              # None lets Omnipose calculate # of Euler iterations (usually &lt;20) but you can tune it for over/under segmentation\n              'augment': False,  # Can optionally rotate the image and average outputs, usually not needed\n              'affinity_seg': False,  # new feature, stay tuned...\n              }\n\n    tic = time.time()\n    if len(images.shape) == 2:\n        try:\n            masks, flows, styles = model.eval(images, **params)\n        except ValueError as e:\n            logging.error(f\"Error in Omnipose segmentation: {e}\")\n            logging.info(\"Error in Omnipose segmentation. A blank mask will be returned.\")\n            masks = np.zeros_like(images)\n            flows = np.zeros_like(images)\n    else:\n        n_images = len(images)\n        n = range(n_images)\n\n        masks_list, flows_list, styles = model.eval([images[i] for i in n], **params)\n\n        # Convert list of masks to 3D array\n        masks = np.dstack(masks_list)  # Transpose to match the original shape of the stack\n        masks = np.moveaxis(masks, -1, 0)\n\n        flows = np.copy(masks)\n\n        for i, sublist in enumerate(flows_list):\n            flows[i] = sublist[-1]  # -1\n\n    net_time = time.time() - tic\n    logging.info('Total segmentation time: {}s'.format(net_time))\n\n    if filter_options:\n        masks = filter_mask(masks, filter_options)\n\n    return masks, flows\n</code></pre> <p>Function to filter the segmentation mask basaed on basic morphological criteria such as area, length and width.</p> <p>Parameters:</p> Name Type Description Default <code>mask</code> <code>np.array</code> <p>The mask to filter. If a single mask is provided, it should be a 2D array. If multiple masks are provided, they should be a 3D array with shape (n_masks, height, width).</p> required <code>options</code> <code>dict</code> <p>A dictionary containing the filter options for the segmentation. The options are: - min_area: The minimum area of the bacteria. - max_area: The maximum area of the bacteria. - min_length: The minimum length of the bacteria. - max_length: The maximum length of the bacteria. - min_width: The minimum width of the bacteria. - max_width: The maximum width of the bacteria.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>filtered_mask</code> <code>np.ndarray</code> <p>The filtered mask. If a single mask is provided, it will be a 2D array. If multiple masks are provided, it will be a 3D array with shape (n_masks, height, width).</p> Source code in <code>src\\micromorph\\segmentation\\segmentation_tools.py</code> <pre><code>def filter_mask(mask:np.array, options: dict ={}) -&gt; np.array:\n    \"\"\"\n    Function to filter the segmentation mask basaed on basic morphological criteria such as area, length and width.\n\n    Parameters\n    ----------\n    mask: np.ndarray\n        The mask to filter. If a single mask is provided, it should be a 2D array. If multiple masks are provided, they should be a 3D array with shape (n_masks, height, width).\n    options: dict\n        A dictionary containing the filter options for the segmentation. The options are:\n        - min_area: The minimum area of the bacteria.\n        - max_area: The maximum area of the bacteria.\n        - min_length: The minimum length of the bacteria.\n        - max_length: The maximum length of the bacteria.\n        - min_width: The minimum width of the bacteria.\n        - max_width: The maximum width of the bacteria.\n\n    Returns\n    -------\n    filtered_mask: np.ndarray\n        The filtered mask. If a single mask is provided, it will be a 2D array. If multiple masks are provided, it will be a 3D array with shape (n_masks, height, width).\n    \"\"\"\n    # Based on this: https://forum.image.sc/t/need-help-with-regionprops/30107/2\n\n    # Get values from dictionary if they exist, otherwise use default values\n    min_area = options.get(\"min_area\", None)\n    max_area = options.get(\"max_area\", None)\n\n    min_length = options.get(\"min_length\", None)\n    max_length = options.get(\"max_length\", None)\n\n    min_width = options.get(\"min_width\", None)\n    max_width = options.get(\"max_width\", None)\n\n    # Not sure if needed ---\n    # label_mask = label(mask)\n    label_mask = np.copy(mask)\n\n    if len(label_mask.shape) == 2:\n        # Start by getting regionprops\n        regions = regionprops(label_mask)\n\n        # Create a list to store the indices of the bacteria that meet the criteria\n        bacteria_indices = []\n        # Create a new mask with only the bacteria that meet the criteria\n        filtered_mask = np.zeros_like(mask)\n\n        # Loop through the regions\n        for i, region in enumerate(regions):\n            # Get the area, length and width of the region\n            area = region.area\n            length = region.axis_major_length\n            width = region.axis_minor_length\n\n            # Check if the region meets the criteria\n            if (min_area is None or area &gt;= min_area) and (max_area is None or area &lt;= max_area) and \\\n                    (min_length is None or length &gt;= min_length) and (max_length is None or length &lt;= max_length) and \\\n                    (min_width is None or width &gt;= min_width) and (max_width is None or width &lt;= max_width):\n                # If the region meets the criteria, add the index to the list\n                bacteria_indices.append(region.label)\n\n        for i in bacteria_indices:\n            filtered_mask[label_mask == i] = i\n    elif len(label_mask.shape) == 3:\n        # Create stack to store the filtered masks\n        filtered_mask = np.zeros_like(mask)\n\n        # Loop through the frames\n        for i, current_mask in enumerate(label_mask):\n            current_filtered_mask = filter_mask(current_mask, options=options)\n\n            filtered_mask[i] = current_filtered_mask\n    else:\n        raise ValueError(\"Mask must be 2D or 3D.\")\n\n    return filtered_mask\n</code></pre>"},{"location":"API/shape_analysis/","title":"Shape Analysis","text":"<p>The functions used to calculate morphological parameters of the bacteria. </p>"},{"location":"API/shape_analysis/#micromorph.bacteria.shape_analysis.extend_medial_axis","title":"<code>extend_medial_axis(medial_axis: np.array, boundary: np.array, max_iter: int = 50, error_threshold: float = 0.05, min_distance_to_boundary: int = 1, step_size: float or int = 1) -&gt; np.array</code>","text":"<p>Extend the medial axis to the boundary, using the boundary as a reference, then smooth it to get the final result.</p> <p>Parameters:</p> Name Type Description Default <code>medial_axis</code> <code>np.array</code> <p>The medial axis.</p> required <code>boundary</code> <code>np.array</code> <p>The boundary.</p> required <code>max_iter</code> <code>int</code> <p>The maximum number of iterations for extending the medial axis(default is 50).</p> <code>50</code> <code>min_distance_to_boundary</code> <code>int</code> <p>The minimum distance to the boundary (default is 1). This determines when the extension stops.</p> <code>1</code> <code>step_size</code> <code>float or int</code> <p>The step size to take when extending the medial axis (default is 1 px).</p> <code>1</code> <p>Returns:</p> Name Type Description <code>extended_medial_axis</code> <code>np.array</code> <p>The extended and smoothed medial axis.</p> Source code in <code>src\\micromorph\\bacteria\\shape_analysis.py</code> <pre><code>def extend_medial_axis(medial_axis: np.array, boundary: np.array, max_iter: int = 50,\n                       error_threshold: float = 0.05, min_distance_to_boundary: int = 1, step_size: float or int = 1) -&gt; np.array:\n    \"\"\"\n    Extend the medial axis to the boundary, using the boundary as a reference, then smooth it to get the final result.\n\n    Parameters\n    ----------\n    medial_axis : np.array\n        The medial axis.\n    boundary : np.array\n        The boundary.\n    max_iter : int, optional\n        The maximum number of iterations for extending the medial axis(default is 50).\n    min_distance_to_boundary : int, optional\n        The minimum distance to the boundary (default is 1). This determines when the extension stops.\n    step_size : float or int, optional\n        The step size to take when extending the medial axis (default is 1 px).\n\n    Returns\n    -------\n    extended_medial_axis: np.array\n        The extended and smoothed medial axis.\n    \"\"\"\n\n    medial_axis_extended_roughly = extend_medial_axis_roughly(medial_axis, boundary, step_size=0.05)\n\n\n    # medial_axis_extended = smooth_medial_axis(medial_axis_extended_roughly, boundary, error_threshold=0.0005)\n\n    return medial_axis_extended_roughly\n</code></pre>"},{"location":"API/shape_analysis/#micromorph.bacteria.shape_analysis.extend_medial_axis_roughly","title":"<code>extend_medial_axis_roughly(medax, bnd, max_iter=500, min_distance_to_boundary=1, step_size=1)</code>","text":"<p>Extend the medial axis to the boundary, without any smoothing.</p> <p>Parameters:</p> Name Type Description Default <code>medax</code> <code>np.array</code> <p>The medial axis.</p> required <code>bnd</code> <code>np.array</code> <p>The boundary.</p> required <code>max_iter</code> <code>int</code> <p>The maximum number of iterations (default is 50).</p> <code>500</code> <code>min_distance_to_boundary</code> <code>int</code> <p>The minimum distance to the boundary (default is 1).</p> <code>1</code> <code>step_size</code> <code>int</code> <p>The step size to take (default is 1).</p> <code>1</code> <p>Returns:</p> Name Type Description <code>extended_medial_axis</code> <code>np.array</code> <p>The extended medial axis.</p> Source code in <code>src\\micromorph\\bacteria\\shape_analysis.py</code> <pre><code>def extend_medial_axis_roughly(medax, bnd, max_iter=500, min_distance_to_boundary=1, step_size=1):\n    \"\"\"\n    Extend the medial axis to the boundary, without any smoothing.\n\n    Parameters\n    ----------\n    medax : np.array\n        The medial axis.\n    bnd : np.array\n        The boundary.\n    max_iter : int, optional\n        The maximum number of iterations (default is 50).\n    min_distance_to_boundary : int, optional\n        The minimum distance to the boundary (default is 1).\n    step_size : int, optional\n        The step size to take (default is 1).\n\n    Returns\n    -------\n    extended_medial_axis : np.array\n        The extended medial axis.\n    \"\"\"\n    medax_ext = np.copy(medax)\n\n    # Generate a polygon to use for checking if the points are inside the boundary\n    boundary_polygon = Polygon(bnd)\n    # medial_axis = np.array([point for point in medial_axis if Point(point).within(boundary_polygon)])\n\n    # We need to check that there's at least two points in the medial axis\n    if medax.shape[0] &lt; 2:\n        return medax_ext\n\n    # Direction second to last to last point\n    direction = np.arctan2(medax[-1, 1] - medax[-2, 1], medax[-1, 0] - medax[-2, 0])\n\n    dist_to_bound = np.inf\n    N = 0\n    while N &lt; max_iter: #dist_to_bound &gt; min_distance_to_boundary and \n        step_vector = step_size * np.array([np.cos(direction), np.sin(direction)])\n        next_point = medax_ext[-1, :] + step_vector\n        distances = np.sqrt((next_point[0] - bnd[:, 0]) ** 2 + (next_point[1] - bnd[:, 1]) ** 2)\n\n        # check if the next point is outside the boundary\n        if Point(next_point[0], next_point[1]).within(boundary_polygon):\n            # logging.info(\"Next point is inside. Continuing\")\n            medax_ext = np.vstack((medax_ext, next_point))  \n        else:\n            # logging.info(\"Next point is outside. Stopping\")\n            medax_ext = np.vstack((medax_ext, next_point))  \n            break\n\n\n        N += 1\n\n    # FIXME: UGLY - probably needs a second function which is called twice, not this ...\n    # Repeat in the opposite direction\n\n    # Direction second to first point\n    direction = np.arctan2(medax[1, 1] - medax[0, 1], medax[1, 0] - medax[0, 0])\n\n    dist_to_bound = np.inf\n    N = 0\n    while N &lt; max_iter: # dist_to_bound &gt; min_distance_to_boundary and \n        step_vector = -step_size * np.array([np.cos(direction), np.sin(direction)]) * 2\n        next_point = medax_ext[0, :] + step_vector\n    #     dist_to_bound = np.min(np.sqrt((next_point[0] - bnd[:, 0]) ** 2 + (next_point[1] - bnd[:, 1]) ** 2))\n    #     # check if the next point is outside the boundaryp\n    #     logging.info(f\"Next point: {next_point}, distance to boundary: {dist_to_bound}\")\n        # check if the next point is outside the boundary#\n        if Point(next_point[0], next_point[1]).within(boundary_polygon):\n            medax_ext = np.vstack((next_point, medax_ext))\n        else:\n            logging.debug(\"Next point is outside. Stopping\")\n            break\n\n        N += 1\n\n    # remove first and last point\n    medax_ext = np.delete(medax_ext, 0, axis=0)\n    medax_ext = np.delete(medax_ext, -1, axis=0)\n\n    return medax_ext\n</code></pre>"},{"location":"API/shape_analysis/#micromorph.bacteria.shape_analysis.get_bacteria_boundary","title":"<code>get_bacteria_boundary(mask: np.array, boundary_smoothing_factor: int or None = 7) -&gt; np.array</code>","text":"<p>Get the (smoothed) boundary of a segmented bacterium.</p> <p>Parameters:</p> Name Type Description Default <code>mask</code> <code>np.array</code> <p>The binary image (with a single bacterium only).</p> required <code>boundary_smoothing_factor</code> <code>int or None</code> <p>The number of frequencies to use for FFT smoothing (default is 7).</p> <code>7</code> <p>Returns:</p> Name Type Description <code>boundary</code> <code>np.array</code> <p>XY coordinates of the boundary (smoothed).</p> Source code in <code>src\\micromorph\\bacteria\\shape_analysis.py</code> <pre><code>def get_bacteria_boundary(mask: np.array, boundary_smoothing_factor: int or None = 7) -&gt; np.array:\n    \"\"\"\n    Get the (smoothed) boundary of a segmented bacterium.\n\n    Parameters\n    ----------\n    mask : np.array\n        The binary image (with a single bacterium only).\n    boundary_smoothing_factor : int or None, optional\n        The number of frequencies to use for FFT smoothing (default is 7).\n\n    Returns\n    -------\n    boundary: np.array\n        XY coordinates of the boundary (smoothed).\n    \"\"\"\n\n    # Get initial coordinates for boundary coords\n    boundary_xy = get_boundary_coords(mask)\n    # boundary_xy = fix_coordinates_order(boundary_xy) # Performance of this may be questionable.\n\n    if boundary_smoothing_factor is None:\n        return boundary_xy\n    else:\n        x = boundary_xy[:, 0]\n        y = boundary_xy[:, 1]\n\n        x_fft = np.fft.rfft(x)\n        x_fft[boundary_smoothing_factor:] = 0\n\n        y_fft = np.fft.rfft(y)\n        y_fft[boundary_smoothing_factor:] = 0\n\n        x_smoothed = np.fft.irfft(x_fft)\n        y_smoothed = np.fft.irfft(y_fft)\n\n        boundary_xy_smoothed = np.column_stack((x_smoothed, y_smoothed))\n        return np.fliplr(boundary_xy_smoothed)\n</code></pre>"},{"location":"API/shape_analysis/#micromorph.bacteria.shape_analysis.get_bacteria_length","title":"<code>get_bacteria_length(medial_axis_extended: np.array, pxsize: float or int = 1.0) -&gt; float</code>","text":"<p>Calculate the length of a segmented bacterium.</p> <p>Parameters:</p> Name Type Description Default <code>medial_axis_extended</code> <code>np.array</code> <p>The extended medial axis of the bacterium, whose arclength is calculated.</p> required <code>pxsize</code> <code>float</code> <p>The pixel size of the image. The final distance will be multiplied by this value (default is 1.0).</p> <code>1.0</code> <p>Returns:</p> Name Type Description <code>total_distance</code> <code>float</code> <p>Total distance covered by the extended medial axis (in px).</p> Source code in <code>src\\micromorph\\bacteria\\shape_analysis.py</code> <pre><code>def get_bacteria_length(medial_axis_extended: np.array, pxsize: float or int = 1.0) -&gt; float:\n    \"\"\"\n    Calculate the length of a segmented bacterium.\n\n    Parameters\n    ----------\n    medial_axis_extended : np.array\n        The extended medial axis of the bacterium, whose arclength is calculated.\n    pxsize : float, optional\n        The pixel size of the image. The final distance will be multiplied by this value (default is 1.0).\n\n    Returns\n    -------\n    total_distance : float\n        Total distance covered by the extended medial axis (in px).\n    \"\"\"\n\n    # Get distance vectors\n    distance_vectors = np.diff(medial_axis_extended, axis=0)\n    distance_vectors = np.concatenate((np.array([[0, 0]]), distance_vectors))\n\n    # From the vectors, calculate the sums\n    distances_individual = np.sqrt(np.sum(distance_vectors ** 2, axis=1))\n\n    # now get total distance\n    total_distance = np.sum(distances_individual)*pxsize\n\n    return total_distance\n</code></pre>"},{"location":"API/shape_analysis/#micromorph.bacteria.shape_analysis.get_bacteria_widths","title":"<code>get_bacteria_widths(img: np.array, med_ax: np.array, n_lines: int = 5, pxsize: float or int = 1.0, psfFWHM: float or int = 0.25, fit_type: str or None = None, line_magnitude: float or int = 20) -&gt; np.array</code>","text":"<p>Calculate the width of a segmented bacterium.</p> <p>Parameters:</p> Name Type Description Default <code>img</code> <code>np.array</code> <p>The original image.</p> required <code>med_ax</code> <code>np.array</code> <p>The medial axis which will be used to find profile lines to fit.</p> required <code>n_lines</code> <code>int</code> <p>The number of lines to fit (default is 5).</p> <code>5</code> <code>pxsize</code> <code>float or int</code> <p>The pixel size of the image (default is 1.0).</p> <code>1.0</code> <code>psfFWHM</code> <code>float or int</code> <p>The FWHM of the PSF (default is 5).</p> <code>0.25</code> <code>fit_type</code> <code>str or None</code> <p>The type of fit to use (default is None).</p> <code>None</code> <code>line_magnitude</code> <code>float or int</code> <p>The length of the line used to measure the profile (default is 20).</p> <code>20</code> <p>Returns:</p> Name Type Description <code>all_widths</code> <code>np.array</code> <p>Array of widths.</p> Source code in <code>src\\micromorph\\bacteria\\shape_analysis.py</code> <pre><code>def get_bacteria_widths(img: np.array, med_ax: np.array, n_lines: int = 5, pxsize: float or int = 1.0,\n                        psfFWHM: float or int = 0.250, fit_type: str or None = None,\n                        line_magnitude: float or int = 20) -&gt; np.array:\n    \"\"\"\n    Calculate the width of a segmented bacterium.\n\n    Parameters\n    ----------\n    img : np.array\n        The original image.\n    med_ax : np.array\n        The medial axis which will be used to find profile lines to fit.\n    n_lines : int, optional\n        The number of lines to fit (default is 5).\n    pxsize : float or int, optional\n        The pixel size of the image (default is 1.0).\n    psfFWHM : float or int, optional\n        The FWHM of the PSF (default is 5).\n    fit_type : str or None, optional\n        The type of fit to use (default is None).\n    line_magnitude : float or int, optional\n        The length of the line used to measure the profile (default is 20).\n\n    Returns\n    -------\n    all_widths: np.array\n        Array of widths.\n    \"\"\"\n    xh, yh, xl, yl = get_width_profile_lines(med_ax, n_points=n_lines, line_magnitude=line_magnitude)\n\n    profile_points = np.column_stack((xh, yh, xl, yl))\n\n    all_widths = np.array([])\n\n    for points in profile_points:\n        # img or bound_transform\n        current_profile = profile_line(img, (points[1], points[0]), (points[3], points[2]))\n\n        x = np.arange(0, len(current_profile)) * pxsize\n\n        try:\n            if fit_type == 'fluorescence':\n                result = fit_ring_profile(x, current_profile, psfFWHM)\n                width = result.params['R'] * 2\n            elif fit_type == 'phase':\n                result = fit_phase_contrast_profile(x, current_profile)\n                width = result.params['width'].value * 2 * (np.log(2)/2) ** (0.25)\n            elif fit_type == 'tophat':\n                result = fit_top_hat_profile(x, current_profile)\n                width = result.params['width'].value * 2 * (np.log(2)/2) ** (0.25)\n            else:\n                raise ValueError('Invalid fit type - please choose \"fluorescence\" or \"phase\".')\n\n            all_widths = np.append(all_widths, width)\n        except:\n            # logging.info(\"Error fitting profile, skipping this one.\")\n            pass\n\n    return all_widths\n</code></pre>"},{"location":"API/shape_analysis/#micromorph.bacteria.shape_analysis.get_medial_axis","title":"<code>get_medial_axis(mask: np.array) -&gt; np.array</code>","text":"<p>Get the medial axis of a segmented bacterium.</p> <p>Parameters:</p> Name Type Description Default <code>mask</code> <code>np.array</code> <p>The binary image (with a single bacterium only).</p> required <p>Returns:</p> Name Type Description <code>medial_axis</code> <code>np.array</code> <p>The medial axis of the bacterium.</p> Source code in <code>src\\micromorph\\bacteria\\shape_analysis.py</code> <pre><code>def get_medial_axis(mask: np.array) -&gt; np.array:\n    \"\"\"\n    Get the medial axis of a segmented bacterium.\n\n    Parameters\n    ----------\n    mask : np.array\n        The binary image (with a single bacterium only).\n\n    Returns\n    -------\n    medial_axis : np.array\n        The medial axis of the bacterium.\n    \"\"\"\n    bacteria_skeleton = skeletonize(mask)\n\n    # Get the medial axis\n    bacteria_skeleton = prune_short_branches(bacteria_skeleton)\n\n    # Get the medial axis\n    medial_axis = trace_axis(bacteria_skeleton)\n\n    return medial_axis\n</code></pre>"},{"location":"API/shape_analysis/#micromorph.bacteria.shape_analysis.smooth_medial_axis","title":"<code>smooth_medial_axis(medial_axis: np.array, boundary: np.array, error_threshold: float = 0.05, max_iter: int = 50, spline_val: int = 1, spline_spacing=0.25) -&gt; np.array</code>","text":"<p>Smooth the medial axis of a segmented bacterium, using the boundary as a reference.</p> <p>Parameters:</p> Name Type Description Default <code>medial_axis</code> <code>np.array</code> <p>The medial axis of the bacterium.</p> required <code>boundary</code> <code>np.array</code> <p>The boundary of the bacterium.</p> required <code>error_threshold</code> <code>float</code> <p>The threshold for the error in the smoothing (default is 0.05).</p> <code>0.05</code> <code>max_iter</code> <code>int</code> <p>The maximum number of iterations for the smoothing (default is 50).</p> <code>50</code> <p>Returns:</p> Name Type Description <code>smoothed_medial_axis</code> <code>np.array</code> <p>The smoothed medial axis.</p> Source code in <code>src\\micromorph\\bacteria\\shape_analysis.py</code> <pre><code>def smooth_medial_axis(medial_axis: np.array, boundary: np.array, error_threshold: float = 0.05, max_iter: int = 50, spline_val: int = 1, spline_spacing = 0.25) -&gt; np.array:\n    \"\"\"\n    Smooth the medial axis of a segmented bacterium, using the boundary as a reference.\n\n    Parameters\n    ----------\n    medial_axis : np.array\n        The medial axis of the bacterium.\n    boundary : np.array\n        The boundary of the bacterium.\n    error_threshold : float, optional\n        The threshold for the error in the smoothing (default is 0.05).\n    max_iter : int, optional\n        The maximum number of iterations for the smoothing (default is 50).\n\n    Returns\n    -------\n    smoothed_medial_axis: np.array\n        The smoothed medial axis.\n    \"\"\"\n    # Sanity check that all points in the medial axis are INSIDE the boundary.\n    # This is due to the fact that we use the smoothed boundary for this calculation, but the medial axis is\n    # calculated from the mask, which can lead to points extending outside the boundary\n\n    boundary_polygon = Polygon(boundary)\n    medial_axis = np.array([point for point in medial_axis if Point(point).within(boundary_polygon)])\n\n    # smooth medial axis before starting\n    # smooth the points\n    x = medial_axis[:, 0]\n    y = medial_axis[:, 1]\n\n    # need to calculate arclength of the medial axis, so we can use it for smoothing\n    distances = np.sqrt(np.sum(np.diff(medial_axis, axis=0) ** 2, axis=1))\n    distances = np.concatenate((np.array([0]), distances))  # add 0 for the first point\n    total_arclength_distance = np.cumsum(distances)  # cumulative sum to get the arclength\n\n    # n_spline_points is such that each point should be spaced px_spacing apart\n    n_spline_points = int(np.ceil(total_arclength_distance[-1] / spline_spacing))\n\n    # we are fitting x and y independently of each other\n    try:\n        indexes = np.arange(0, len(x), 1)\n\n        tck_s = splrep(indexes, x, s=len(x), k=spline_val)\n        x_smooth_s = BSpline(*tck_s)\n\n        tck_sy = splrep(indexes, y, s=len(y), k=spline_val)\n        y_smooth_s = BSpline(*tck_sy)\n    except:\n        return medial_axis\n\n    calculation_values = np.linspace(0, len(x) - 1, n_spline_points)\n\n    medial_axis = np.array([x_smooth_s(calculation_values), y_smooth_s(calculation_values)]).T\n\n    iter_n = 0\n    previous_error = np.inf\n    while iter_n &lt; max_iter:\n        # logging.info(f\"Starting iteration {iter_n}\")\n        middle_points = []\n        all_points = []\n        perpendicular_points = []\n\n        for i in range(medial_axis.shape[0] - 1):\n            # calculate the angle between the first and second point of the medial axis\n            angle = np.arctan2(medial_axis[i + 1, 1] - medial_axis[i, 1], medial_axis[i + 1, 0] - medial_axis[i, 0])\n\n            # now find the angle perpendicular to this angle\n            angle_perpendicular = angle + np.pi / 2\n\n            # calculate the middle point between the first and second point of the medial axis\n            middle_point = (medial_axis[i + 1] + medial_axis[i]) / 2\n\n\n            # get the closest point on the boundary to the perpendicular line\n            distances = np.abs((boundary[:, 1] - middle_point[1]) * np.cos(angle_perpendicular) - (\n                        boundary[:, 0] - middle_point[0]) * np.sin(angle_perpendicular))\n\n\n\n            # get the index of the closest point\n            # FIXME: this is ugly, but it works\n            idx = np.argmin(distances)\n\n            closest_point = boundary[idx]\n\n            # get the second closest\n            distances[idx] = np.inf\n            idx = np.argmin(distances)\n            closest_point2 = boundary[idx]\n\n            perpendicular_points.append(closest_point)\n            perpendicular_points.append(closest_point2)\n\n            # get the middle point between the two closest points\n            middle_point = (closest_point + closest_point2) / 2\n            middle_points.append(middle_point)\n\n            all_points.append(medial_axis[i])\n            all_points.append(middle_point)\n            all_points.append(medial_axis[i + 1])\n\n        # convert to numpy array\n        all_points = np.array(all_points)\n        all_points = np.array([point for point in all_points if Point(point).within(boundary_polygon)])\n\n\n        # smooth the points\n        x = all_points[:, 0]\n        y = all_points[:, 1]\n\n        # we are fitting x and y independently of each other\n        indexes = np.arange(0, len(x), 1)\n\n        tck_s = splrep(indexes, x, s=len(x), k=spline_val)\n        x_smooth_s = BSpline(*tck_s)\n\n        tck_sy = splrep(indexes, y, s=len(y), k=spline_val)\n        y_smooth_s = BSpline(*tck_sy)\n\n        calculation_values = np.linspace(0, len(x) - 1, n_spline_points)\n\n        all_points = np.array([x_smooth_s(calculation_values), y_smooth_s(calculation_values)]).T\n\n        # check if there are any large deviations in the smoothed points\n        # if there are, we need to stop the smoothing\n        delta_x = np.abs(np.diff(all_points[:, 0]))\n        if np.max(delta_x) &gt; 100:\n            # logging.info(f\"Large deviation in x, stopping smoothing here. Delta is {np.max(delta_x)}\")\n            break\n\n        if iter_n &gt;= 0:\n            current_error = np.abs(np.mean(all_points - medial_axis))\n            # logging.info(f\"Current error: {current_error}, iteration: {iter_n}/{max_iter}\")\n            if current_error &gt; previous_error:\n                pass\n                # logging.info(\"Error increased, stopping smoothing here.\")\n                # break\n            elif current_error &lt; error_threshold:\n                medial_axis = all_points\n                # logging.info(\"Error below threshold, stopping smoothing here.\")\n                break\n            else:\n                medial_axis = all_points\n                previous_error = current_error\n\n        iter_n += 1\n    return medial_axis\n</code></pre>"},{"location":"API/shape_analysis/#utility-functions","title":"Utility Functions","text":"<p>Collection of utility functions used to calculate morphological parameters of the bacteria, mostly to do with binary  image processing.</p>"},{"location":"API/shape_analysis/#micromorph.bacteria.utilities.apply_mask_to_image","title":"<code>apply_mask_to_image(img: np.array, mask: np.array, method: str = 'min') -&gt; np.array</code>","text":"<p>A function to apply a dilation to a mask, and then apply the mask to the image. This makes all the points outside the region of interest black.</p> <p>Parameters:</p> Name Type Description Default <code>img</code> <code>np.array</code> <p>The image to be masked</p> required <code>mask</code> <code>np.array</code> <p>The mask to be applied to the image</p> required <p>Returns:</p> Name Type Description <code>img_masked</code> <code>np.array</code> <p>The masked image</p> Source code in <code>src\\micromorph\\bacteria\\utilities.py</code> <pre><code>def apply_mask_to_image(img: np.array, mask: np.array, method: str = 'min') -&gt; np.array:\n    \"\"\"\n    A function to apply a dilation to a mask, and then apply the mask to the image.\n    This makes all the points outside the region of interest black.\n\n    Parameters\n    ----------\n    img : np.array\n        The image to be masked\n    mask : np.array\n        The mask to be applied to the image\n\n    Returns\n    -------\n    img_masked : np.array\n        The masked image\n    \"\"\"\n\n    mask_inverted = np.invert(np.copy(mask))\n\n    img_masked = np.copy(img)\n\n    # Below is to avoid problems with different data types\n    if mask_inverted.dtype == 'bool':\n        idx = mask_inverted == True\n    else:\n        idx = mask_inverted == 255\n\n    # img_masked[idx] = np.mean(img)\n    if method == 'min':\n        img_masked[idx] = np.min(img)\n    elif method == 'max':\n        img_masked[idx] = np.max(img)\n    elif method == 'mean':\n        img_masked[idx] = np.mean(img)\n    else:\n        # raise a warning\n        Warning('Method not recognised, using min instead')\n        img_masked[idx] = np.min(img)\n\n    return img_masked\n</code></pre>"},{"location":"API/shape_analysis/#micromorph.bacteria.utilities.calculate_distance_along_line","title":"<code>calculate_distance_along_line(coordinates: np.array) -&gt; np.array</code>","text":"<p>Function to calculate the distance along a line defined by a set of coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>coordinates</code> <code>np.array</code> <p>An np.array with 2 columns and N rows (N being the number of points in the line).</p> required <p>Returns:</p> Name Type Description <code>distances_cumulative</code> <code>np.array</code> <p>An np.array with 1 column and N rows (N being the number of points in the line).</p> Source code in <code>src\\micromorph\\bacteria\\utilities.py</code> <pre><code>def calculate_distance_along_line(coordinates: np.array) -&gt; np.array:\n    \"\"\"\n    Function to calculate the distance along a line defined by a set of coordinates.\n\n    Parameters\n    ----------\n    coordinates : np.array\n        An np.array with 2 columns and N rows (N being the number of points in the line).\n\n    Returns\n    -------\n    distances_cumulative : np.array\n        An np.array with 1 column and N rows (N being the number of points in the line).\n    \"\"\"\n    # Get distance vectors\n    distance_vectors = np.diff(coordinates, axis=0)\n    distance_vectors = np.concatenate((np.array([[0, 0]]), distance_vectors))\n\n    # From the vectors, calculate the sums\n    distances_individual = np.sqrt(np.sum(distance_vectors ** 2, axis=1))\n    distances_cumulative = np.cumsum(distances_individual)\n\n    return distances_cumulative\n</code></pre>"},{"location":"API/shape_analysis/#micromorph.bacteria.utilities.find_branchpoints","title":"<code>find_branchpoints(skeleton: np.array) -&gt; np.array</code>","text":"<p>Function to find the branchpoints of a binary image containing a skeleton.</p> <p>Parameters:</p> Name Type Description Default <code>skeleton</code> <code>np.array</code> <p>The skeletonised binary image</p> required <p>Returns:</p> Name Type Description <code>branch_points</code> <code>np.array</code> <p>A binary image with only the branchpoints of the skeleton</p> Source code in <code>src\\micromorph\\bacteria\\utilities.py</code> <pre><code>def find_branchpoints(skeleton: np.array) -&gt; np.array:\n    \"\"\"\n    Function to find the branchpoints of a binary image containing a skeleton.\n\n    Parameters\n    ----------\n    skeleton : np.array\n        The skeletonised binary image\n\n    Returns\n    -------\n    branch_points : np.array\n        A binary image with only the branchpoints of the skeleton\n    \"\"\"\n    selems = list()\n    selems.append(np.array([[0, 1, 0], [1, 1, 1], [0, 0, 0]]))\n    selems.append(np.array([[1, 0, 1], [0, 1, 0], [1, 0, 0]]))\n    selems.append(np.array([[1, 0, 1], [0, 1, 0], [0, 1, 0]]))\n    selems.append(np.array([[0, 1, 0], [1, 1, 0], [0, 0, 1]]))\n    selems.append(np.array([[0, 0, 1], [1, 1, 1], [0, 1, 0]]))\n    selems = [np.rot90(selems[i], k=j) for i in range(5) for j in range(4)]\n\n    selems.append(np.array([[0, 1, 0], [1, 1, 1], [0, 1, 0]]))\n    selems.append(np.array([[1, 0, 1], [0, 1, 0], [1, 0, 1]]))\n\n    branch_points = np.zeros_like(skeleton, dtype=bool)\n    for selem in selems:\n        branch_points |= binary_hit_or_miss(skeleton, selem)\n\n    return branch_points\n</code></pre>"},{"location":"API/shape_analysis/#micromorph.bacteria.utilities.find_closest_boundary_to_axis","title":"<code>find_closest_boundary_to_axis(medial_axis_coords: np.array, boundary_coords: np.array, start_position: int) -&gt; np.array</code>","text":"<p>A function to find the closest point on the boundary to the medial axis.</p> <p>Parameters:</p> Name Type Description Default <code>medial_axis_coords</code> <code>np.array</code> <p>An np.array with 2 columns and N rows (N being the number of points in the medial axis).</p> required <code>boundary_coords</code> <code>np.array</code> <p>An np.array with 2 columns and M rows (M being the number of points in the boundary).</p> required <code>start_position</code> <code>int</code> <p>Either 1 or -1. If 1, the medial axis will be ordered from the first point to the last. If -1, the medial axis will be ordered from the last point to the first.</p> required <p>Returns:</p> Name Type Description <code>closest_on_boundary</code> <code>np.array</code> <p>An np.array with 2 columns and 1 row, the coordinates of the closest point on the boundary.</p> Source code in <code>src\\micromorph\\bacteria\\utilities.py</code> <pre><code>def find_closest_boundary_to_axis(medial_axis_coords: np.array, boundary_coords: np.array,\n                                  start_position: int) -&gt; np.array:\n    \"\"\"\n    A function to find the closest point on the boundary to the medial axis.\n\n    Parameters\n    ----------\n    medial_axis_coords : np.array\n        An np.array with 2 columns and N rows (N being the number of points in the medial axis).\n    boundary_coords : np.array\n        An np.array with 2 columns and M rows (M being the number of points in the boundary).\n    start_position : int\n        Either 1 or -1. If 1, the medial axis will be ordered from the first point to the last. If -1, the medial axis will be ordered from the last point to the first.\n\n    Returns\n    -------\n    closest_on_boundary : np.array\n        An np.array with 2 columns and 1 row, the coordinates of the closest point on the boundary.\n    \"\"\"\n    # Start position can be either 1 or -1\n    if start_position == 1:\n        pass\n    else:\n        medial_axis_coords = np.flipud(medial_axis_coords)\n\n    endpoint = medial_axis_coords[0, :]\n\n    if len(medial_axis_coords) &gt; 10:\n        points_of_interest = medial_axis_coords[1:10, :]\n    else:\n        points_of_interest = medial_axis_coords[1::, :]\n\n    search_vectors = points_of_interest - endpoint\n    # This is to fix bug that happens when medial_axis_coords is only two points.\n    if len(search_vectors) == 2:\n        search_vectors = np.reshape(search_vectors, [1, 2])\n\n    search_angles = np.arctan2(search_vectors[:, 1], search_vectors[:, 0])\n\n    mean_search_angle = np.mean(search_angles)\n\n    # Get angles from endpoint to all the boundary points.\n    vectors_to_boundary_points = endpoint - boundary_coords\n    angles_to_boundary_points = np.arctan2(vectors_to_boundary_points[:, 1], vectors_to_boundary_points[:, 0])\n\n    selected_points = np.where((angles_to_boundary_points &gt; mean_search_angle - 0.3) &amp;\n                               (angles_to_boundary_points &lt; mean_search_angle + 0.3))\n\n    # Filter the boundary points\n    filtered_boundary_points = boundary_coords[selected_points, :]\n\n    # closest_on_boundary = find_closest_point(endpoint, filtered_boundary_points)\n    closest_on_boundary = find_furthest_point(endpoint, filtered_boundary_points)\n    closest_on_boundary = np.array(closest_on_boundary[0][0])\n    return closest_on_boundary\n</code></pre>"},{"location":"API/shape_analysis/#micromorph.bacteria.utilities.find_closest_point","title":"<code>find_closest_point(point: np.array, candidates: np.array) -&gt; tuple[np.array, int]</code>","text":"<p>Find the closest point to a given point, from a list of candidates.</p> <p>Parameters:</p> Name Type Description Default <code>point</code> <code>np.array</code> <p>A np.array with 2 columns and 1 row (x, y)</p> required <code>candidates</code> <code>np.array</code> <p>An np.array with 2 columns and N rows (N being the number of candidates)</p> required <p>Returns:</p> Name Type Description <code>closest_point</code> <code>np.array</code> <p>The closest point</p> <code>min_index</code> <code>int</code> <p>The index of the closest point in the candidates array</p> Source code in <code>src\\micromorph\\bacteria\\utilities.py</code> <pre><code>def find_closest_point(point: np.array, candidates: np.array) -&gt; tuple[np.array, int]:\n    \"\"\"\n    Find the closest point to a given point, from a list of candidates.\n\n    Parameters\n    ----------\n    point : np.array\n        A np.array with 2 columns and 1 row (x, y)\n    candidates : np.array\n        An np.array with 2 columns and N rows (N being the number of candidates)\n\n    Returns\n    -------\n    closest_point : np.array\n        The closest point\n    min_index : int\n        The index of the closest point in the candidates array\n    \"\"\"\n\n    distances_xy = candidates - point\n\n    distances = np.sum(np.square(distances_xy), 1)\n\n    min_index = np.where(distances == np.min(distances))\n\n    min_index = min_index[0][0]  # Ensures we take the first one if there's two points with same distance\n\n    closest_point = candidates[min_index, :]\n\n    return closest_point, min_index\n</code></pre>"},{"location":"API/shape_analysis/#micromorph.bacteria.utilities.find_endpoints","title":"<code>find_endpoints(img: np.array) -&gt; np.array</code>","text":"<p>A function to find the endpoints of a binary image containing a line (i.e., a medial axis).</p> <p>Parameters:</p> Name Type Description Default <code>img</code> <code>np.array</code> <p>The binary image.</p> required <p>Returns:</p> Name Type Description <code>endpoints</code> <code>np.array</code> <p>A binary image with only the endpoints of the line.</p> Source code in <code>src\\micromorph\\bacteria\\utilities.py</code> <pre><code>def find_endpoints(img: np.array) -&gt; np.array:\n    \"\"\"\n        A function to find the endpoints of a binary image containing a line (i.e., a medial axis).\n\n        Parameters\n        ----------\n        img : np.array\n            The binary image.\n\n        Returns\n        -------\n        endpoints : np.array\n            A binary image with only the endpoints of the line.\n    \"\"\"\n    endpoints = np.zeros(np.shape(img))\n\n    endpoint_options = np.array([[1, 0, 0],\n                                 [0, 1, 0],\n                                 [0, 0, 0],\n                                 [0, 1, 0],\n                                 [0, 1, 0],\n                                 [0, 0, 0],\n                                 [0, 0, 1],\n                                 [0, 1, 0],\n                                 [0, 0, 0],\n                                 [0, 0, 0],\n                                 [0, 1, 1],\n                                 [0, 0, 0],\n                                 [0, 0, 0],\n                                 [0, 1, 0],\n                                 [0, 0, 1],\n                                 [0, 0, 0],\n                                 [0, 1, 0],\n                                 [0, 1, 0],\n                                 [0, 0, 0],\n                                 [0, 1, 0],\n                                 [1, 0, 0],\n                                 [0, 0, 0],\n                                 [1, 1, 0],\n                                 [0, 0, 0],\n                                 ])\n\n    endpoint_structures = np.reshape(endpoint_options, (8, 3, 3))\n\n    for box in endpoint_structures:\n        current_attempt = binary_hit_or_miss(img, box)\n\n        endpoints = endpoints + current_attempt\n    return endpoints\n</code></pre>"},{"location":"API/shape_analysis/#micromorph.bacteria.utilities.find_furthest_point","title":"<code>find_furthest_point(point: np.array, candidates: np.array) -&gt; tuple[np.array, int]</code>","text":"<p>Find the furthest point from a given point, from a list of candidates.</p> <p>Parameters:</p> Name Type Description Default <code>point</code> <code>np.array</code> <p>A np.array with 2 columns and 1 row (x, y)</p> required <code>candidates</code> <code>np.array</code> <p>An np.array with 2 columns and N rows (N being the number of candidates)</p> required <p>Returns:</p> Name Type Description <code>closest_point</code> <code>np.array</code> <p>The furthest point</p> <code>max_index</code> <code>int</code> <p>The index of the furthest point in the candidates array</p> Source code in <code>src\\micromorph\\bacteria\\utilities.py</code> <pre><code>def find_furthest_point(point: np.array, candidates: np.array) -&gt; tuple[np.array, int]:\n    \"\"\"\n    Find the furthest point from a given point, from a list of candidates.\n\n\n    Parameters\n    ----------\n    point : np.array\n        A np.array with 2 columns and 1 row (x, y)\n    candidates : np.array\n        An np.array with 2 columns and N rows (N being the number of candidates)\n\n    Returns\n    -------\n    closest_point : np.array\n        The furthest point\n    max_index : int\n        The index of the furthest point in the candidates array\n    \"\"\"\n    distances_xy = candidates - point\n\n    distances = np.sum(np.square(distances_xy), 1)\n\n    max_index = np.where(distances == np.max(distances))\n\n    max_index = max_index[0][0]  # Ensures we take the first one if there's two points with same distance\n\n    closest_point = candidates[max_index, :]\n\n    return closest_point, max_index\n</code></pre>"},{"location":"API/shape_analysis/#micromorph.bacteria.utilities.fix_coordinates_order","title":"<code>fix_coordinates_order(coordinates: np.array) -&gt; np.array</code>","text":"<p>This function fixes the coordinate order in a list of points (usually extracted from a binary image). In shorts, it picks a point and then finds the closest point to it, and so on.</p> <p>Parameters:</p> Name Type Description Default <code>coordinates</code> <code>np.array</code> <p>An np.array with 2 columns and N rows (N being the number of points)</p> required <p>Returns:</p> Name Type Description <code>ordered_coordinates</code> <code>np.array</code> <p>An np.array with 2 columns and N rows (N being the number of points)</p> Source code in <code>src\\micromorph\\bacteria\\utilities.py</code> <pre><code>def fix_coordinates_order(coordinates: np.array) -&gt; np.array:\n    \"\"\"\n    This function fixes the coordinate order in a list of points (usually extracted from a binary image).\n    In shorts, it picks a point and then finds the closest point to it, and so on.\n\n    Parameters\n    ----------\n    coordinates : np.array\n        An np.array with 2 columns and N rows (N being the number of points)\n\n    Returns\n    -------\n    ordered_coordinates : np.array\n        An np.array with 2 columns and N rows (N being the number of points)\n    \"\"\"\n    ordered_coordinates = np.zeros(coordinates.shape)\n\n    # Set first coordinate of the boundary\n    ordered_coordinates[0, :] = coordinates[0, :]\n    coordinates = np.delete(coordinates, 0, 0)\n\n    for i, point in enumerate(ordered_coordinates, start=1):\n        previous_point = ordered_coordinates[i - 1, :]\n        if coordinates.shape[0] &gt; 1:\n            closest_point, index = find_closest_point(previous_point, coordinates)\n\n            ordered_coordinates[i, :] = closest_point\n\n            coordinates = np.delete(coordinates, index, 0)\n        else:\n            candidate = np.array([[coordinates[0][0], coordinates[0][1]]])\n\n            distance_to_candidate = np.sqrt(np.sum((candidate - previous_point) ** 2))\n\n            if distance_to_candidate &lt; 3:\n                ordered_coordinates[i, 0] = coordinates[0][0]\n                ordered_coordinates[i, 1] = coordinates[0][1]\n            else:\n                ordered_coordinates = np.delete(ordered_coordinates, i, 0)\n            break\n\n    return ordered_coordinates\n</code></pre>"},{"location":"API/shape_analysis/#micromorph.bacteria.utilities.get_boundary_coords","title":"<code>get_boundary_coords(binary_image: np.array) -&gt; np.array</code>","text":"<p>Runs the find boundary function from skimage, and then extracts the coordinates of the boundary.</p> <p>Parameters:</p> Name Type Description Default <code>binary_image</code> <code>np.array</code> <p>A binary image</p> required <p>Returns:</p> Name Type Description <code>boundary_xy</code> <code>np.array</code> <p>An np.array with 2 columns and N rows (N being the number of boundary pixels). The points will not be ordered.</p> Source code in <code>src\\micromorph\\bacteria\\utilities.py</code> <pre><code>def get_boundary_coords(binary_image: np.array) -&gt; np.array:\n    \"\"\"\n    Runs the find boundary function from skimage, and then extracts the coordinates of the boundary.\n\n    Parameters\n    ----------\n    binary_image : np.array\n        A binary image\n\n    Returns\n    -------\n    boundary_xy : np.array\n        An np.array with 2 columns and N rows (N being the number of boundary pixels). The points will not be ordered.\n    \"\"\"\n\n    # Get boundaries from binary image\n    # boundary_img = find_boundaries(binary_image, connectivity=4, mode='inner', background=0)\n    boundary_xy = find_contours(binary_image)[0]\n\n    # # ...and extract coordinates\n    # boundary_xy = get_coords(boundary_img)\n    return boundary_xy\n</code></pre>"},{"location":"API/shape_analysis/#micromorph.bacteria.utilities.get_coords","title":"<code>get_coords(binary_image: np.array) -&gt; np.array</code>","text":"<p>A function to get the coordinates of the non-zero pixels in a binary image.</p> <p>Parameters:</p> Name Type Description Default <code>binary_image</code> <code>np.array</code> <p>A binary image</p> required <p>Returns:</p> Name Type Description <code>xy</code> <code>np.array</code> <p>An np.array with 2 columns and N rows (N being the number of non-zero pixels)</p> Source code in <code>src\\micromorph\\bacteria\\utilities.py</code> <pre><code>def get_coords(binary_image: np.array) -&gt; np.array:\n    \"\"\"\n    A function to get the coordinates of the non-zero pixels in a binary image.\n\n    Parameters\n    ----------\n    binary_image : np.array\n        A binary image\n\n    Returns\n    -------\n    xy : np.array\n        An np.array with 2 columns and N rows (N being the number of non-zero pixels)\n    \"\"\"\n\n    xy = np.fliplr(np.asarray(np.where(binary_image)).T)\n    return xy\n</code></pre>"},{"location":"API/shape_analysis/#micromorph.bacteria.utilities.get_width_profile_lines","title":"<code>get_width_profile_lines(medial_axis: np.array, n_points: int = 3, line_magnitude: int or float = 10)</code>","text":"<p>Function to get the lines that will be used to calculate the width of the bacterium through fitting.</p> <p>Parameters:</p> Name Type Description Default <code>medial_axis</code> <code>np.array</code> <p>An np.array with 2 columns and N rows (N being the number of points in the medial axis).</p> required <code>n_points</code> <code>int</code> <p>The number of points to sample along the medial axis.</p> <code>3</code> <code>line_magnitude</code> <code>int or float</code> <p>The length of the lines that will be perpendicular to the medial axis.</p> <code>10</code> <p>Returns:</p> Type Description <code>x_high, y_high, x_low, y_low : np.arrays</code> <p>np.arrays with 1 column and N rows (N being the number of points in the medial axis).</p> Source code in <code>src\\micromorph\\bacteria\\utilities.py</code> <pre><code>def get_width_profile_lines(medial_axis: np.array, n_points: int = 3, line_magnitude: int or float = 10):\n    \"\"\"\n    Function to get the lines that will be used to calculate the width of the bacterium through fitting.\n\n    Parameters\n    ----------\n    medial_axis : np.array\n        An np.array with 2 columns and N rows (N being the number of points in the medial axis).\n    n_points : int\n        The number of points to sample along the medial axis.\n    line_magnitude : int or float\n        The length of the lines that will be perpendicular to the medial axis.\n\n    Returns\n    -------\n    x_high, y_high, x_low, y_low : np.arrays\n        np.arrays with 1 column and N rows (N being the number of points in the medial axis).\n    \"\"\"\n\n    # Find slope of medial axis\n    delta_vectors = np.diff(medial_axis, axis=0)\n    parallel_angles = np.arctan2(delta_vectors[:, 1], delta_vectors[:, 0])\n    perpendicular_angles = parallel_angles + np.deg2rad(90)\n\n    # Remove first point from the medial axis, to make it same length as other vectors\n    medial_axis = np.delete(medial_axis, 0, axis=0)\n\n    # Get arclength curves\n    distances = calculate_distance_along_line(medial_axis)\n\n    # Get spline fit of distances vs x\n    x_coords = medial_axis[:, 0]\n    y_coords = medial_axis[:, 1]\n\n\n    if len(distances) &gt; 3:\n        x_spline = splrep(distances, x_coords)\n        y_spline = splrep(distances, y_coords)\n        angles_spline = splrep(distances, perpendicular_angles)\n\n        sampling_distances = np.linspace(0, distances[-1], n_points, endpoint=False)\n\n        x_points = []\n        y_points = []\n        angles = []\n\n        for val in sampling_distances:\n            x_points.append(splev(val, x_spline))\n            y_points.append(splev(val, y_spline))\n            angles.append(splev(val, angles_spline))\n    else:\n        x_points = x_coords\n        y_points = y_coords\n        angles = perpendicular_angles\n\n    x_ref = x_points\n    y_ref = y_points\n    perpendicular_angles = angles\n\n    # Create lines 1 distance_line away from medial axis point, in each direction\n    dx_perp = np.cos(perpendicular_angles) * line_magnitude / 2\n    dy_perp = np.sin(perpendicular_angles) * line_magnitude / 2\n\n    x_high = x_ref + dx_perp\n    y_high = y_ref + dy_perp\n\n    x_low = x_ref - dx_perp\n    y_low = y_ref - dy_perp\n\n    return x_high, y_high, x_low, y_low\n</code></pre>"},{"location":"API/shape_analysis/#micromorph.bacteria.utilities.prune_short_branches","title":"<code>prune_short_branches(skeleton: np.array) -&gt; np.array</code>","text":"<p>Function to find the longest branch in a skeleton.</p> <p>Parameters:</p> Name Type Description Default <code>skeleton</code> <code>np.array</code> <p>The binary image, skeletonised</p> required <p>Returns:</p> Name Type Description <code>pruned_skeleton</code> <code>np.array</code> <p>A binary image with only the longest branch of the skeleton</p> Source code in <code>src\\micromorph\\bacteria\\utilities.py</code> <pre><code>def prune_short_branches(skeleton: np.array) -&gt; np.array:\n    \"\"\"\n    Function to find the longest branch in a skeleton.\n\n    Parameters\n    ----------\n    skeleton : np.array\n        The binary image, skeletonised\n\n    Returns\n    -------\n    pruned_skeleton : np.array\n        A binary image with only the longest branch of the skeleton\n    \"\"\"\n    if not skeleton.dtype == bool:\n        skeleton = skeleton.astype(bool)\n\n    branch_points = find_branchpoints(skeleton)\n    separated_branches = np.copy(skeleton) ^ branch_points\n\n    labelled_branches = label(separated_branches)\n\n    unique_labels = np.unique(labelled_branches)\n\n    # remove zero, as it's the background\n    unique_labels = unique_labels[1:]\n\n    # find the highest occurence\n    max_occurence = 0\n    max_label = 0\n    for n in unique_labels:\n        occurence = np.sum(labelled_branches == n)\n        if occurence &gt; max_occurence:\n            max_occurence = occurence\n            max_label = n\n\n    pruned_skeleton = labelled_branches == max_label\n\n    return pruned_skeleton\n</code></pre>"},{"location":"API/shape_analysis/#micromorph.bacteria.utilities.trace_axis","title":"<code>trace_axis(medial_axis_image: np.array) -&gt; np.array</code>","text":"<p>Trace the medial axis, returning an ordered array of points from one end to the other. The first endpoint is defined as the most leftmost of the endpoints.</p> <p>Parameters:</p> Name Type Description Default <code>medial_axis_image</code> <code>np.array</code> <p>The binary image with the medial axis</p> required <p>Returns:</p> Name Type Description <code>medial_axis</code> <code>np.array</code> <p>An np.array with 2 columns and N rows (N being the number of points in the medial axis)</p> Source code in <code>src\\micromorph\\bacteria\\utilities.py</code> <pre><code>def trace_axis(medial_axis_image: np.array) -&gt; np.array:\n    \"\"\"\n    Trace the medial axis, returning an ordered array of points from one end to the other. The first endpoint is defined as the most leftmost of the endpoints.\n\n    Parameters\n    ----------\n    medial_axis_image : np.array\n        The binary image with the medial axis\n\n    Returns\n    -------\n    medial_axis : np.array\n        An np.array with 2 columns and N rows (N being the number of points in the medial axis)\n    \"\"\"\n    # Want to get medial axis in ordered point list.\n\n    # Get coordinates (unordered) of the medial axis\n    medial_axis_non_ordered = get_coords(medial_axis_image)\n\n    # Grab endpoints of the medial axis line, and get their coordinates\n    endpoints_image = find_endpoints(medial_axis_image)\n    endpoints = get_coords(endpoints_image)\n\n    # Pick one endpoint to start ordering from\n    # This is arbitrary, so let's pick point that is the leftmost\n    chosen_endpoint_index = np.where(endpoints[:, 0] == np.min(endpoints[:, 0]))\n    chosen_endpoint_index = chosen_endpoint_index[0][0]\n\n    # Create a new array where the ordered points will be stored\n    medial_axis = np.zeros(medial_axis_non_ordered.shape)\n\n    # Assign first point, and remove it from medial_axis_non_ordered\n    medial_axis[0, :] = endpoints[chosen_endpoint_index, :]\n\n    index_to_delete = np.where((medial_axis_non_ordered[:, 0] == endpoints[chosen_endpoint_index, 0]) &amp;\n                               (medial_axis_non_ordered[:, 1] == endpoints[chosen_endpoint_index, 1]))\n\n    medial_axis_non_ordered = np.delete(medial_axis_non_ordered, index_to_delete, 0)\n\n    for i, point in enumerate(medial_axis, start=1):\n        previous_point = medial_axis[i - 1, :]\n\n        if medial_axis_non_ordered.shape[0] &gt; 1:\n            closest_point, index = find_closest_point(previous_point, medial_axis_non_ordered)\n\n            medial_axis[i, :] = closest_point\n\n            # Delete point from pool\n            medial_axis_non_ordered = np.delete(medial_axis_non_ordered, index, 0)\n        else:\n            medial_axis[i, 0] = medial_axis_non_ordered[0][0]\n            medial_axis[i, 1] = medial_axis_non_ordered[0][1]\n            break\n\n    return medial_axis\n</code></pre>"},{"location":"napari-micromorph/analysis/","title":"Analysing an Image","text":""},{"location":"napari-micromorph/analysis/#choosing-the-analysis-parameters","title":"Choosing the analysis parameters","text":""},{"location":"napari-micromorph/analysis/#interacting-with-your-results","title":"Interacting with your results","text":""},{"location":"napari-micromorph/analysis/#saving-your-results","title":"Saving your results","text":""},{"location":"napari-micromorph/analysis/#batch-processing","title":"Batch processing","text":"<p>Once you're happy with your analysis settings, you can choose to batch analyse multiple files and folders at once. If you are interested in doing this you can refer to the batch tools guide. You can access the batch tools by running <code>micromorph-batch</code> or clicking on the \"Batch Tools\" button in the napari plugin, which opens the same GUI.</p>"},{"location":"napari-micromorph/installation/","title":"Installation","text":"<p>Important</p> <p>Before you can install napari-micromorph, you need to have a working napari installation. Please refer to the installation guide before continuing.</p>"},{"location":"napari-micromorph/installation/#install-as-python-package","title":"Install as Python package","text":"<p>If you have installed napari by creating an environment, you can install napari-micromorph by running the command <code>pip install napari-micromorph</code>. This will install both the <code>micromorph</code> and <code>napari-micromorph</code> packages, and will enable you to also use <code>micromorph</code> in scripts and jupyter notebooks if you later prefer to do so.</p> <p>If the installation has been successful, you will be able to start a napari instance with the plugin pre-loaded by running: <code>napari-micromorph</code></p>"},{"location":"napari-micromorph/installation/#install-from-napari-plugin-interface","title":"Install from napari plugin interface","text":"<p>If you would like a command-line-free experience, you can do so by launching napari, then clicking on <code>Plugins &gt; Install/Uninstall Plugins...</code> and looking for <code>napari-micromorph</code>. After that you can click on the \"Install\" button and everything will be installed for you. You should close and re-launch napari after the installation is complete.</p> <p>You can check the installation has been successful by launching napari and checking that the plugin appears in the Plugins dropdown menu.</p>"},{"location":"napari-micromorph/segmentation/","title":"Segmenting your images","text":""},{"location":"napari-micromorph/segmentation/#opening-the-sample-image","title":"Opening the sample image","text":"Your browser does not support the video tag."},{"location":"napari-micromorph/segmentation/#segmentation","title":"Segmentation","text":"Your browser does not support the video tag."},{"location":"napari-micromorph/segmentation/#applying-filters-to-the-image-mask","title":"Applying filters to the image mask","text":"Your browser does not support the video tag."},{"location":"usage/api_example/","title":"Using the API in a custom script","text":"<p>Warning</p> <p>This page is still work in progress, so some parts may be incomplete or missing. We are working on it!</p> <p>The package allows users to directly access the functions and classes used in the napari plugin, meaning that those  can be easily integrated into custom routines.</p> <p>Details of the API functions and classes can be found in the API documentation (see menu on the left). </p> <p>In this simple example, we load an image and a pre-made mask, and then calculate the properties of the bacteria in  that image.</p> <pre><code>from skimage.io import imread\nfrom micromorph import get_bacteria_list\nfrom micromorph.measure360 import run_measure360\n\nimport matplotlib.pyplot as plt\n\nif __name__ == \"__main__\":\n    # Load image and the corresponding mask\n    image_stack = imread(\"path/to/image\")\n    mask_stack = imread(\"path/to/mask\")\n\n\n    # Get measure360 values for the cells in the stack\n    bacteria_list = run_measure360(image_stack, mask_stack, options={'n_angles': 50, 'pxsize': 65, 'fit_type': 'phase', 'psfFWHM': 250})\n\n    # or use get_bacteria_list to use \"normal mode\"\n    # bacteria_list = get_bacteria_list(image_stack, mask_stack, options={'pxsize': 65, 'n_widths': 5, 'fit_type': 'fluorescence', 'psfFWHM': 250})\n\n    # Get widths and lengths\n    widths = [bacteria.width for bacteria in bacteria_list]\n    lengths = [bacteria.length for bacteria in bacteria_list]\n\n    # Plot histograms\n    fig, ax = plt.subplots(1, 2, figsize=(12, 5))\n    ax[0].hist(widths, bins=30, color='blue', alpha=0.7)\n    ax[0].set_title('Width Distribution')\n\n    ax[1].hist(lengths, bins=30, color='green', alpha=0.7)\n    ax[1].set_title('Length Distribution')\n    plt.show()\n</code></pre> <p>You can find various example scripts in the micromorph GitHub repository.</p>"},{"location":"usage/batch_tools_example/","title":"Batch processing the data","text":"<p>Warning</p> <p>This page is still work in progress, so some parts may be incomplete or missing. We are working on it!</p> <p>A batch processing panel is available if <code>micromorph</code> was installed on your environment with <code>pip install micromorph[gui]</code>.</p> <p>After that, the panel can opened by running the command</p> <p><code>micromorph-batch</code></p> <p></p> <p>You can add folders to be analysed by copying their path into the text box and clicking <code>Add Folder</code>. The batch utility will specifically look for <code>.tif</code> files in the selected folders and subfolders. We are looking at ways to make this suitable for a broader format of files. If <code>Run Segmentation</code> is checked, the segmentation will be run on the selected folders and save masks in the same  folder as the images, with the same name as the image but with <code>_mask</code> appended.</p> <p>If <code>Load Segmentation</code> is checked, the batch utility will look for masks in the selected folders, assuming the same  naming convention described above.</p> <p><code>Analysis Settings</code> and <code>Segmentation Settings</code> are the same as the settings window in the main napari plugin (see  here for more information).,  while  <code>Image Loading Settings</code>  allows some extra flexibility with regards to how images are loaded. In general you shouldn't need to change it but  may want to if, for example, you only want to analyse a specific half of the image etc.</p>"},{"location":"usage/napari_plugin_example/","title":"Analysing images using the napari plugin","text":"<p>Warning</p> <p>This page is still work in progress, so some parts may be incomplete or missing. We are working on it!</p> <p>The napari plugin is designed to allow you to analyse your images and interact with parameters such as filters,  segmentation methods etc to optimise the analysis before using the batch tools to analyse multiple images in one go.  The plugin also has basic plotting functionalities which should allow you to get a sense of whether results make  sense or not.</p> <p>Generally, analysis will consist of the following steps:</p> <ol> <li>Open <code>napari</code> and load the plugin</li> <li>Load an image (or single-channel stack)</li> <li>Load a mask, or use omnipose to segment your image</li> <li>Check the segmentation and adjust parameters if necessary</li> <li>Use one of two methods to analyse the image(s)</li> <li>Interact with the result, using the basic plotting functionalities</li> <li>Save the results and note down parameters used for analysis, to replicate in the batch tools mode</li> </ol> <p>We will now go through each of these steps in more detail.</p>"},{"location":"usage/napari_plugin_example/#opening-napari-and-the-plugin","title":"Opening napari and the plugin","text":"<p>Open napari whichever way you prefer. For example, from the terminal after activating your python environment, by running the command: <code>napari</code>. Once napari is open, you  can select the plugin from the <code>Plugins</code> menu, and select <code>napari-micromorph</code>.</p> <p>You can also directly open a napari instance with the plugin already loaded by running the command: <code>napari-micromorph</code>.</p>"},{"location":"usage/napari_plugin_example/#loading-an-image","title":"Loading an image","text":"<p>You can load an image by clicking on the <code>File</code> menu, and selecting <code>Open File(s)</code>. This will open a file dialog  where you can select the image you want to analyse. You can also drag and drop an image into the napari window.</p> <p>Alternatively, you can drop an image into the napari window, and it will be loaded automatically.</p> <p>You can also load one of the example images that come with the package by clicking on <code>File &gt; Open sample...</code> and selecting one of micromorph example images.</p> <p>(Insert image of napari with image loaded)</p>"},{"location":"usage/napari_plugin_example/#segmenting-the-image","title":"Segmenting the image","text":"<p>We will now segment the image using one of the pre-trained omnipose models. Clicking on the <code>Segmentation Settings</code>  button will open up the following menu:</p> <p></p> <p>Here you can select the model you want to use, and adjust the parameters. Once you are happy with the settings, just  close the window and they will be saved.</p> <p>After that, just click on <code>Run Segmentation</code> and the segmentation will be performed.</p> <p>(Insert image of napari with segmentation performed)</p> <p>You can now proceed to the analysis step, or use the <code>Mask filter utility</code> to remove objects that were segmented  by mistake - an example would be to remove bright spots which the segmentation algorithm thought were bacteria.</p>"},{"location":"usage/napari_plugin_example/#analysing-the-image","title":"Analysing the image","text":"<p>We will now analyse the image using the <code>Run full analysis</code> button. Before we do however, let us check the analysis  settings by clicking on the <code>Analysis Settings</code> button:</p> <p></p> <p>The key parameters which you need to set up here are the pixel size of your image, the full-width half-maximum of  your microscope's psf (point spread function), and the fit type (i.e. whether you are analysing a phase contrast or  fluorescence microscopy image).</p> <p>You can also adjust other parameters applied during the analysis. Specifically, the parameters for each mode are the  following:</p> <p>Full Analysis</p> <ul> <li><code>Number of Widths</code>: The number of widths to fit for each bacterium</li> <li><code>Boundary Smoothing Factor</code>: The number of frequencies to be kept during the boundary smoothing process.</li> </ul> <p>Measure360</p> <ul> <li><code>Number of Widths</code>: The number of widths to fit for each bacterium, i.e. how many angles to measure the width at.</li> <li><code>Filter Results</code> will allow you to apply a filter to the Measure360 to remove any spurious measurements.    <code>Derivative</code> makes sure to remove any results which would be considered spurious due to the derivative of the    curve being too high at that point.</li> </ul>"},{"location":"usage/napari_plugin_example/#exporting-the-results","title":"Exporting the results","text":"<p>Results can be exported using the dedicated buttons, in either <code>csv</code> or <code>pickle</code> formats. The <code>csv</code> format will have  reduced information, while the <code>pickle</code> file will contain the full list of Bacteria objects. (This is likely to change in the future as we move towards being able to export results in a more standardised  format, such as .hdf5).</p>"}]}